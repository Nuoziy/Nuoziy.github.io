<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>hello world twice</title>
    <url>/2024/06/03/hello-world-twice/</url>
    <content><![CDATA[<p><del>这里记下一点杂谈吧</del></p>
<h1 id="2024-7-24"><a href="#2024-7-24" class="headerlink" title="2024&#x2F;7&#x2F;24"></a>2024&#x2F;7&#x2F;24</h1>]]></content>
      <tags>
        <tag>建立博客</tag>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.7.24份题解</title>
    <url>/2024/07/24/2024_7_24%E4%BB%BD%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="T1-最短路"><a href="#T1-最短路" class="headerlink" title="T1 最短路"></a>T1 最短路</h1><blockquote>
<p>给定一个包含 n 个节点和 m 条边的图，每条边有一个权值。<br>你的任务是回答 k 个询问，每个询问包含两个正整数 s 和 t 表示起点和终点，要求寻找&gt;&gt;从 s 到 t 的一条路径，使得路径上权值最大的一条边权值最小。</p>
</blockquote>
<ol>
<li>最短路一定在最小生成树上</li>
<li>跑一边prim，顺便更新ans</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 1020</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i, a, b) for(int i = (a); i &lt;= (b); i ++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> love return</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> you 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> me 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dist[maxn];</span><br><span class="line"><span class="type">int</span> n,m,k;</span><br><span class="line"><span class="type">int</span> cosent[maxn][maxn];</span><br><span class="line"><span class="type">int</span> ans[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> to[maxn];</span><br><span class="line"><span class="type">bool</span> f[maxn];</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;a.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;a.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(cosent, inf, <span class="built_in">sizeof</span>(cosent));</span><br><span class="line">    <span class="built_in">memset</span>(ans,<span class="number">0</span>, <span class="built_in">sizeof</span>(ans));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">0</span>, n)</span><br><span class="line">    &#123;</span><br><span class="line">        to[i] = i;</span><br><span class="line">        dist[i] = inf; </span><br><span class="line">        cosent[i][i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u, v, w;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(cosent[u][v] &gt; w)</span><br><span class="line">        &#123;</span><br><span class="line">            cosent[u][v] = cosent[v][u] = w;</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mx = inf;</span><br><span class="line">        <span class="type">int</span> v = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">rep</span>(j, <span class="number">1</span>, n) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!f[j] &amp;&amp; dist[j] &lt; mx)</span><br><span class="line">            &#123;</span><br><span class="line">                v = j;</span><br><span class="line">                mx = dist[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(v==<span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">rep</span>(j, <span class="number">1</span>, n) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(f[j])</span><br><span class="line">            &#123;</span><br><span class="line">                ans[v][j] = ans[j][v] = <span class="built_in">max</span>(ans[to[v]][j], mx);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        f[v] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="built_in">rep</span>(j, <span class="number">1</span>, n) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!f[j] &amp;&amp; cosent[v][j] &lt; dist[j])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = cosent[v][j];</span><br><span class="line">                to[j] = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u, v; cin &gt;&gt; u &gt;&gt; v; </span><br><span class="line">        cout &lt;&lt; (ans[u][v] == <span class="number">0</span> ? <span class="number">-1</span> : ans[u][v]) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    love you;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="T2-序列"><a href="#T2-序列" class="headerlink" title="T2 序列"></a>T2 序列</h1><p>找性质，待更</p>
<h1 id="T3-函数"><a href="#T3-函数" class="headerlink" title="T3 函数"></a>T3 函数</h1><p>数位dp，待更</p>
<h1 id="T3-游戏"><a href="#T3-游戏" class="headerlink" title="T3 游戏"></a>T3 游戏</h1><p>nim游戏，待更</p>
]]></content>
      <tags>
        <tag>题解汇总</tag>
      </tags>
  </entry>
  <entry>
    <title>扫描线</title>
    <url>/2024/07/24/%E6%89%AB%E6%8F%8F%E7%BA%BF/</url>
    <content><![CDATA[<p>from OI-WIKI</p>
<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>在二维坐标系上，给出多个矩形的左下以及右上坐标，求出所有矩形构成的图形的面积。</p>
<h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><p>现在假设我们有一根线，从下往上开始扫描：<br><del>(图片)</del></p>
<ol>
<li>如图所示，我们可以把整个矩形分成如图各个颜色不同的小矩形，那么这个小矩形的高就是我们扫过的距离，那么剩下了一个变量，那就是矩形的长一直在变化。</li>
<li>我们的线段树就是为了维护矩形的长，我们给每一个矩形的上下边进行标记，下面的边标记为 $1$，上面的边标记为 $-1$，每遇到一个矩形时，我们知道了标记为 $1$ 的边，我们就加进来这一条矩形的长，等到扫描到 $-1$ 时，证明这一条边需要删除，就删去，利用 $1$ 和 $-1$ 可以轻松的到这种状态。</li>
<li>还要注意这里的线段树指的并不是线段的一个端点，而指的是一个区间，所以我们要计算的是 $r+1$ 和 $r-1$。</li>
<li>需要 离散化。</li>
</ol>
<p>附上代码及注释：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 1000020</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i, a, b) for(int i = (a); i &lt;= (b); i ++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lson (rt&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rson (rt&lt;&lt;1|1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mid ((l+r)&gt;&gt;1)</span></span><br><span class="line"><span class="comment">//记得加括号（（</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> love return</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> you 0</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> segment_tree</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l, r, len, sum;</span><br><span class="line">        <span class="comment">//记录节点的左端点，右端点，此点对应的长度，以及我们需要增加总长度还是减小总长度（是矩形的靠前边否）</span></span><br><span class="line">    &#125;st[maxn&lt;&lt;<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">segment</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l, r, h, vul; </span><br><span class="line">        <span class="comment">//记录此线段的左端点右端点，高度和靠前边否</span></span><br><span class="line">    &#125;segg[maxn&lt;&lt;<span class="number">2</span>];</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(segment a, segment b)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        love a.h &lt; b.h;</span><br><span class="line">        <span class="comment">//我们需要将边按照高度排序</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> X[maxn];</span><br><span class="line">    <span class="comment">//记录线段树中需要存储的点（不相同的点）</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> rt)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(st[rt].sum)</span><br><span class="line">        &#123;</span><br><span class="line">            st[rt].len = X[st[rt].r + <span class="number">1</span>] - X[st[rt].l];</span><br><span class="line">            <span class="comment">//当被完全覆盖的节点需要改变时改变</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            st[rt].len = st[lson].len + st[rson].len;</span><br><span class="line">            <span class="comment">//不是被完全覆盖的节点或者此节点没有贡献</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        love ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> rt, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        st[rt].l = l; st[rt].r = r;</span><br><span class="line">        st[rt].len = <span class="number">0</span>; st[rt].sum = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">if</span>(l == r) </span><br><span class="line">        &#123;</span><br><span class="line">            love ;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="built_in">build</span>(lson, l, mid);</span><br><span class="line">        <span class="built_in">build</span>(rson, mid + <span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">        love ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> rt, <span class="type">int</span> al_l, <span class="type">int</span> al_r, <span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = st[rt].l, r = st[rt].r;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(X[l] &gt;= al_r || X[r + <span class="number">1</span>] &lt;= al_l) love ;</span><br><span class="line">        <span class="comment">//剪枝</span></span><br><span class="line">        <span class="keyword">if</span>(X[l] &gt;= al_l &amp;&amp; X[r + <span class="number">1</span>] &lt;= al_r)</span><br><span class="line">        &#123;</span><br><span class="line">            st[rt].sum += val;</span><br><span class="line">            <span class="comment">//如果此节点被完全覆盖</span></span><br><span class="line">            <span class="built_in">pushup</span>(rt);</span><br><span class="line">            <span class="comment">//在此时就回传</span></span><br><span class="line">            love ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">update</span>(lson, al_l, al_r, val);</span><br><span class="line">        <span class="built_in">update</span>(rson, al_l, al_r, val);</span><br><span class="line">        <span class="built_in">pushup</span>(rt);</span><br><span class="line">        <span class="comment">//回传</span></span><br><span class="line">        love ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">1</span>, n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x1, y1, x2, y2; cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2;</span><br><span class="line">            <span class="comment">//输入</span></span><br><span class="line">            segg[(i &lt;&lt; <span class="number">1</span>) - <span class="number">1</span>] = (segment)&#123;x1, x2, y1, <span class="number">1</span>&#125;;</span><br><span class="line">            segg[(i &lt;&lt; <span class="number">1</span>)]     = (segment)&#123;x1, x2, y2, <span class="number">-1</span>&#125;;</span><br><span class="line">            <span class="comment">//我们需要存n*2条边，这里的处理只是为了存储恰好为n*2，没有有顺序的意思</span></span><br><span class="line">            X[(i &lt;&lt; <span class="number">1</span>) - <span class="number">1</span>] = x1;</span><br><span class="line">            X[(i &lt;&lt; <span class="number">1</span>)] = x2;</span><br><span class="line">            <span class="comment">//存点</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        n &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">sort</span>(segg + <span class="number">1</span>, segg + <span class="number">1</span> + n, cmp);</span><br><span class="line">        <span class="built_in">sort</span>(X + <span class="number">1</span>, X + n + <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> cnt = <span class="built_in">unique</span>(X + <span class="number">1</span>, X + n + <span class="number">1</span>) - X - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//去重函数，重点记忆！</span></span><br><span class="line">        <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, cnt - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//建树</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// rep(i, 1, n) cout &lt;&lt; segg[i].h &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">// rep(i, 1, n) cout &lt;&lt; X[i] &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">1</span>, n - <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">update</span>(<span class="number">1</span>, segg[i].l, segg[i].r, segg[i].vul); </span><br><span class="line">            ans += st[<span class="number">1</span>].len * (segg[i + <span class="number">1</span>].h - segg[i].h);</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">        love you;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;a.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;a.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    segment_tree::<span class="built_in">main</span>();</span><br><span class="line"></span><br><span class="line">    love you;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>一道例题 <a href="https://luogu.com.cn/problem/P1502">P1502</a></p>
<p>附上<del>我也不知道怎么对</del>的代码。。。<br><del>回头再调</del></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">// #define int long long</span><br><span class="line">#define rep(i, a, b) for(int i = (a); i &lt;= (b); i ++)</span><br><span class="line">#define lson (rt&lt;&lt;1)</span><br><span class="line">#define rson (rt&lt;&lt;1|1)</span><br><span class="line">// #define mi ((l+r)&gt;&gt;1)</span><br><span class="line">#define maxn 300010</span><br><span class="line">#define int long long</span><br><span class="line">#define love return</span><br><span class="line">#define you 0</span><br><span class="line">int T, n, w, h, C[maxn];</span><br><span class="line">// 组数，元素个数，宽，高</span><br><span class="line"></span><br><span class="line">// namespace line_sweep</span><br><span class="line">// &#123;</span><br><span class="line">    // int C[maxn&lt;&lt;2];</span><br><span class="line">    //存横坐标</span><br><span class="line">    struct segment&#123;</span><br><span class="line">        int l,r,h;</span><br><span class="line">        int val;</span><br><span class="line">        bool operator &lt;(const segment &amp;a)const&#123;</span><br><span class="line">            return (h!=a.h)?h&lt;a.h:val&gt;a.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;segg[maxn&lt;&lt;2];</span><br><span class="line">    struct node&#123;</span><br><span class="line">        int l,r;</span><br><span class="line">        int mx,add;</span><br><span class="line">    &#125;st[maxn&lt;&lt;2];</span><br><span class="line"></span><br><span class="line">    void pushup(int rt)</span><br><span class="line">    &#123;</span><br><span class="line">        st[rt].mx = max(st[lson].mx, st[rson].mx);    </span><br><span class="line">        //上推</span><br><span class="line">        love ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void pushdown(int rt)</span><br><span class="line">    &#123;</span><br><span class="line">        st[lson].mx += st[rt].add;</span><br><span class="line">        st[rson].mx += st[rt].add;</span><br><span class="line">        st[lson].add += st[rt].add;</span><br><span class="line">        st[rson].add += st[rt].add;</span><br><span class="line"></span><br><span class="line">        st[rt].add = 0;</span><br><span class="line">        //下推</span><br><span class="line">        love ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void build(int rt, int l, int r)//建树</span><br><span class="line">    &#123;</span><br><span class="line">        st[rt].l = l, st[rt].r = r;</span><br><span class="line">        st[rt].add = 0; st[rt].mx = 0;</span><br><span class="line">        if(l == r) love ;</span><br><span class="line">        int mi = (l+r)&gt;&gt;1;</span><br><span class="line">        build(lson, l, mi);</span><br><span class="line">        build(rson, mi + 1, r);</span><br><span class="line">    &#125;</span><br><span class="line">    // void build(int x,int l,int r)&#123;</span><br><span class="line">    //     st[x].l=l,st[x].r=r,st[x].mx=st[x].add=0;</span><br><span class="line">    //     if(l==r)return;</span><br><span class="line">    //     int mi=(l+r)&gt;&gt;1;</span><br><span class="line">    //     build(x&lt;&lt;1,l,mi);</span><br><span class="line">    //     build(x&lt;&lt;1|1,mi+1,r);</span><br><span class="line">    // &#125;</span><br><span class="line"></span><br><span class="line">    void update(int rt, int al_l, int al_r, int val)//上传</span><br><span class="line">    &#123;</span><br><span class="line">        int l = st[rt].l, r = st[rt].r;</span><br><span class="line">        if(l &gt;= al_l &amp;&amp; r &lt;= al_r)</span><br><span class="line">        &#123;</span><br><span class="line">            st[rt].mx += val;</span><br><span class="line">            st[rt].add += val;</span><br><span class="line">            love ;</span><br><span class="line">        &#125;</span><br><span class="line">        pushdown(rt);</span><br><span class="line">        </span><br><span class="line">	    int mi=(l+r)&gt;&gt;1;</span><br><span class="line">        if(al_l &lt;= mi)update(lson, al_l, al_r, val);</span><br><span class="line">        if(al_r &gt; mi)update(rson, al_l, al_r, val);</span><br><span class="line">        pushup(rt);</span><br><span class="line">    &#125;</span><br><span class="line">    void init()//初始化</span><br><span class="line">    &#123;</span><br><span class="line">        memset(segg, 0, sizeof(segg));</span><br><span class="line">        memset(st, 0, sizeof(st));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // signed main()</span><br><span class="line">    // &#123;</span><br><span class="line">    //     init();</span><br><span class="line">    //     rep(i, 1, n)</span><br><span class="line">    //     &#123;</span><br><span class="line">    //         int x, y, v; cin &gt;&gt; x &gt;&gt; y &gt;&gt; v;</span><br><span class="line">    //         C[(i &lt;&lt; 1) - 1] = y; </span><br><span class="line">    //         C[(i &lt;&lt; 1)] = y + h - 1;</span><br><span class="line">    //         segg[(i &lt;&lt; 1) - 1] = (segment)&#123;y, y + h - 1, x, v&#125;;</span><br><span class="line">    //         segg[(i &lt;&lt; 1)] = (segment)&#123;y, y + h - 1, x + w - 1, -v&#125;;</span><br><span class="line">    //     &#125;</span><br><span class="line"></span><br><span class="line">    //     n &lt;&lt;= 1;</span><br><span class="line"></span><br><span class="line">    //     sort(segg + 1, segg + n + 1);</span><br><span class="line">    //     sort(X + 1, X + n + 1);</span><br><span class="line">    //     int cnt = unique(X + 1, X + n + 1) - (X + 1);</span><br><span class="line"></span><br><span class="line">    //     rep(i, 1, n)</span><br><span class="line">    //     &#123;</span><br><span class="line">    //         int pos1 = lower_bound(X + 1, X + cnt + 1, segg[i].l) - X;</span><br><span class="line">    //         int pos2 = lower_bound(X + 1, X + cnt + 1, segg[i].r) - X;</span><br><span class="line">    //         segg[i].r = pos2; </span><br><span class="line">    //         segg[i].l = pos1;</span><br><span class="line">    //     &#125;</span><br><span class="line"></span><br><span class="line">    //     build(1, 1, cnt);</span><br><span class="line"></span><br><span class="line">    //     int ans = 0;</span><br><span class="line"></span><br><span class="line">    //     rep(i, 1, n)</span><br><span class="line">    //     &#123;</span><br><span class="line">    //         update(1, segg[i].l, segg[i].r, segg[i].val);</span><br><span class="line">    //         ans = max(ans, st[1].mx);</span><br><span class="line">    //     &#125;</span><br><span class="line"></span><br><span class="line">    //     cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        // love you;</span><br><span class="line">    // &#125;</span><br><span class="line">// &#125;</span><br><span class="line"></span><br><span class="line">signed main()</span><br><span class="line">&#123;</span><br><span class="line">    // freopen(&quot;a.in&quot;, &quot;r&quot;, stdin);</span><br><span class="line">    // freopen(&quot;a.out&quot;, &quot;w&quot;, stdout);</span><br><span class="line">    // cin &gt;&gt; T;</span><br><span class="line">    // while(T --)</span><br><span class="line">    // &#123;</span><br><span class="line">// 3 5 4</span><br><span class="line">// 1 2 3</span><br><span class="line">// 2 3 2</span><br><span class="line">// 6 3 1</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; w &gt;&gt; h;</span><br><span class="line">        // init();</span><br><span class="line">        rep(i, 1, n)</span><br><span class="line">        &#123;</span><br><span class="line">            int x, y, v; cin &gt;&gt; x &gt;&gt; y &gt;&gt; v;</span><br><span class="line">            C[(i &lt;&lt; 1) - 1] = y; </span><br><span class="line">            C[(i &lt;&lt; 1)] = y + h - 1;</span><br><span class="line">            segg[(i &lt;&lt; 1) - 1] = (segment)&#123;y, y + h - 1, x, v&#125;;</span><br><span class="line">            segg[(i &lt;&lt; 1)] = (segment)&#123;y, y + h - 1, x + w - 1, -v&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        n &lt;&lt;= 1;</span><br><span class="line"></span><br><span class="line">        sort(segg + 1, segg + n + 1);</span><br><span class="line">        sort(C + 1, C + n + 1);</span><br><span class="line">        int cnt = unique(C + 1, C + n + 1) - (C + 1);</span><br><span class="line"></span><br><span class="line">        rep(i, 1, n)</span><br><span class="line">        &#123;</span><br><span class="line">            int pos1 = lower_bound(C + 1, C + cnt + 1, segg[i].l) - C;</span><br><span class="line">            int pos2 = lower_bound(C + 1, C + cnt + 1, segg[i].r) - C;</span><br><span class="line">            segg[i].r = pos2; </span><br><span class="line">            segg[i].l = pos1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        build(1, 1, cnt);</span><br><span class="line"></span><br><span class="line">        int ans = 0;</span><br><span class="line"></span><br><span class="line">        rep(i, 1, n)</span><br><span class="line">        &#123;</span><br><span class="line">            update(1, segg[i].l, segg[i].r, segg[i].val);</span><br><span class="line">            ans = max(ans, st[1].mx);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">        // line_sweep::main();</span><br><span class="line">    // &#125;</span><br><span class="line"></span><br><span class="line">    love you;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>扫描线</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
</search>
