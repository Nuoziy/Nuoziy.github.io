<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>AC绿题整理</title>
    <url>/2024/07/30/ak%E7%BB%BF%E9%A2%98%E8%AE%A1%E5%88%92/</url>
    <content><![CDATA[<h2 id="P1131ZJOI2007"><a href="#P1131ZJOI2007" class="headerlink" title="P1131ZJOI2007"></a><a href="https://www.luogu.com.cn/problem/P1131">P1131ZJOI2007</a></h2><p>首先可以感性证明这是一颗树, 发现可以贪心地做, 记录一个max, 当子树中的每一个叶子节点都需要补全的时候最优在子树的根与他父亲的边增加长度, 附上代码.<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 500001</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i, a, b) for(int i = (a); i &lt;= (b); i ++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, s;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> leaf[maxn], tim;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> head[maxn], nxt[maxn&lt;&lt;<span class="number">1</span>], dat[maxn&lt;&lt;<span class="number">1</span>], cnt, val[maxn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dat[++ cnt] = v; nxt[cnt] = head[u]; head[u] = cnt; val[cnt] = w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> lg[maxn];</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> mx = -inf;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = head[x]; i; i = nxt[i])</span><br><span class="line">    &#123; </span><br><span class="line">        <span class="type">int</span> da = dat[i];</span><br><span class="line">        <span class="keyword">if</span>(da == fa) <span class="keyword">continue</span>; </span><br><span class="line">        lg[da] = lg[x] + val[i];</span><br><span class="line">        <span class="type">int</span> t = <span class="built_in">dfs</span>(da, x);</span><br><span class="line">        <span class="comment">// if(x == 4) cout &lt;&lt; t &lt;&lt; endl;</span></span><br><span class="line">        sum += t;</span><br><span class="line">        mx = <span class="built_in">max</span>(mx, t);</span><br><span class="line">        </span><br><span class="line">        cnt ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(mx == -inf) mx = lg[x];</span><br><span class="line">    ans += mx*cnt - sum;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; mx &lt;&lt; &quot; &quot; &lt;&lt; cnt &lt;&lt; &quot; &quot; &lt;&lt; sum &lt;&lt; &quot; &quot; &lt;&lt; mx*cnt - sum &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">return</span> mx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;a.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;a.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; s;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        <span class="built_in">add</span>(u, v, w);</span><br><span class="line">        <span class="built_in">add</span>(v, u, w);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs</span>(s, <span class="number">0</span>); </span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>结合</tag>
        <tag>绿题</tag>
      </tags>
  </entry>
  <entry>
    <title>hello world twice</title>
    <url>/2024/06/03/hello-world-twice/</url>
    <content><![CDATA[<p><del>这里记下一点杂谈吧</del></p>
<h1 id="2024-7-24"><a href="#2024-7-24" class="headerlink" title="2024/7/24"></a>2024/7/24</h1>]]></content>
      <tags>
        <tag>建立博客</tag>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title>欧几里得算法, 中国剩余定理</title>
    <url>/2024/07/24/shulun/</url>
    <content><![CDATA[<h1 id="关于gcd-最大公约数-的欧几里得算法"><a href="#关于gcd-最大公约数-的欧几里得算法" class="headerlink" title="关于gcd(最大公约数)的欧几里得算法"></a>关于gcd(最大公约数)的欧几里得算法</h1><h2 id="朴素的欧几里得算法"><a href="#朴素的欧几里得算法" class="headerlink" title="朴素的欧几里得算法"></a>朴素的欧几里得算法</h2><p>欧几里得算法依赖于一个朴素的公式:</p>
<script type="math/tex; mode=display">
gcd(a, b) = gcd(b, a \% b)</script><p>如果 $ a, b $ 的最大公约数为 $c$ , 那么 $ a, a mod b $ 的最大公约数也为 $c$ .<br>易于理解的, $ gcd(a, b) \times lcm(a, b) = a \times b $ .<br>C++的代码实现:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (b ? a : <span class="built_in">gcd</span>(b, a % b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="exgcd-拓展欧几里得算法"><a href="#exgcd-拓展欧几里得算法" class="headerlink" title="exgcd(拓展欧几里得算法)"></a>exgcd(拓展欧几里得算法)</h2><h3 id="exgcd是干什么的"><a href="#exgcd是干什么的" class="headerlink" title="exgcd是干什么的"></a>exgcd是干什么的</h3><p>exgcd可以用于求解如下式子:</p>
<script type="math/tex; mode=display">
    ax + by = gcd(a, b) \tag{1}</script><p>或者</p>
<script type="math/tex; mode=display">
    ax \equiv gcd(a, b) \pmod{b}</script><p>然后进一步求解如下的情况:</p>
<script type="math/tex; mode=display">
    ax + by = c</script><p>显然只要把第一个式子乘上 $ \frac{c}{gcd(a, b)} $ 就可以.</p>
<p>那我们如何求解呢<br>我们设 $d = gcd(a, b) $.<br>首先我们知道如下式显然成立:</p>
<script type="math/tex; mode=display">
    a \% b = a - \lfloor \frac{a}{b} \rfloor \times b \tag{2}</script><p>考虑 $ gcd(a, b) $ 的求解过程:</p>
<script type="math/tex; mode=display">
gcd(a, b) = gcd(b, a \% b)</script><p>我们可以设想一个式子:</p>
<script type="math/tex; mode=display">
    bx' + (a \% b)y' = d \tag{3}</script><p>把 $(1)$ 式代入 $(2)$ 式:</p>
<script type="math/tex; mode=display">
    bx' + (a - \lfloor \frac{a}{b} \rfloor \times b)y' = d</script><p>化简得:</p>
<script type="math/tex; mode=display">
    bx' + ay' - \lfloor \frac{a}{b} \rfloor \times b \times y' = d</script><p>再合并得:</p>
<script type="math/tex; mode=display">
    b(x' + \lfloor \frac{a}{b} \rfloor  y') + ay' = d \tag{4}</script><p>显然 $(4)$ 式和 $(1)$ 式是等价的.<br>于是我们便根据 $(4)$ 推出了 $(1)$ 的解.<br>显然一定有一组解在 $ ({a, b} )= ({1, 0}) $ 下 $ ax + by = gcd(a, b) $ 成立<br>于是我们便可以递归的写出代码:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::pair &lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="built_in">exgcd</span>(<span class="type">int</span> a, <span class="type">int</span> b) &#123;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> [x, y] = <span class="built_in">exgcd</span>(b, b % a);</span><br><span class="line">    <span class="keyword">return</span> &#123;y, x - a/b * y&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="exgcd求逆元"><a href="#exgcd求逆元" class="headerlink" title="exgcd求逆元"></a>exgcd求逆元</h3><p>定义一个同余方程 $ ax \equiv 1 \pmod{ b}$, 即 $ax + by = 1$ , 显然 $a, x$ 互为逆元.<br>运行 $exgcd(a, m) $ 即可.</p>
<h3 id="附-裴蜀定理-Bezout’s-Identity"><a href="#附-裴蜀定理-Bezout’s-Identity" class="headerlink" title="附: 裴蜀定理 (Bézout’s Identity)"></a>附: 裴蜀定理 (Bézout’s Identity)</h3><p>如果 $gcd(a, b) \nmid c $, 则原方程无整数解.</p>
<h1 id="中国剩余定理-CRT"><a href="#中国剩余定理-CRT" class="headerlink" title="中国剩余定理(CRT)"></a>中国剩余定理(CRT)</h1><h2 id="朴素的中国剩余定理解决同余方程组"><a href="#朴素的中国剩余定理解决同余方程组" class="headerlink" title="朴素的中国剩余定理解决同余方程组"></a>朴素的中国剩余定理解决同余方程组</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>例如对于以下的一元线性同余方程组：</p>
<script type="math/tex; mode=display">
\left \{
    \begin{aligned}
    x &\equiv a_{1} \pmod{m_{1}}  \\
    x &\equiv a_{2} \pmod{m_{2}}  \\
    &\vdots                       \\
    x &\equiv a_{n} \pmod{m_{n}}  \\
    \end{aligned}
\right.</script><p>中国剩余定理给出了它的有解的判定条件, 并用构造法给出了在有解情况下解的具体形式.<br>中国剩余定理说明: 假设整数 $ m_1, m_2, … , m_n $ 其中任两数互质，则对任意的整数: $ a_1, a_2, … , a_n$ , 方程组有解，并且通解可以用如下方式构造得到:</p>
<ol>
<li>设 $ M = \prod_{i = 1}^{n} m_i, \ M_i = \frac{M}{m_i}$. 显然 $ M_i$ 是除 $m_i$ 之外 $m$ 集合中所有的元素的乘积.</li>
<li>设 $t_i = M_{i}^{-1}$ , 即 $M_i$ 在 $\%m_i$ 意义下的倒数, 使得 $t_i \cdot M_i  \equiv 1 \pmod{m_i} $.</li>
<li>则 $x = kM + \sum_{i = 1}^{n}a_i t_i M_i$.</li>
</ol>
<h3 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h3><p>易于理解的, $(a \cdot b) \% m = (a \% m) \cdot (b \% m), \ \ \ (a + b) \% m = (a \% m) + (b \% m)$.<br>对于给定的 $ i $, 有 $ \   \ t_i \cdot M_i  \equiv 1 \pmod{m_i} $, 所以有 $ {a_i t_i M_t} \equiv a_i \pmod{m_i} $<br>而对于任意 $j \neq i $ , $ {a_i t_i M_t} \equiv 0 \pmod{m_i} $<br>显然 $\sum_{i = 1}^{n}a_i t_i M_i$ 是方程的一个解.<br>因为 $\forall i, M \% a_i = 0$, 所以 $k \cdot M + \sum_{i = 1}^{n}a_i t_i M_i$ 也是方程的解.</p>
<p>附上代码:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> _crt(<span class="type">int</span> k) &#123;</span><br><span class="line">    <span class="type">int</span> prod = <span class="number">1</span>, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; i ++) prod *= m[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; i ++) &#123;</span><br><span class="line">        <span class="type">int</span> mi = prod / m[i];</span><br><span class="line">        <span class="keyword">auto</span> [x, y] = <span class="built_in">exgcd</span>(mi, m[i]);</span><br><span class="line">        ans += (a[i] * mi * x % prod);</span><br><span class="line">        ans %= prod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (ans % prod + prod) % prod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="exCRT"><a href="#exCRT" class="headerlink" title="exCRT"></a>exCRT</h2><h3 id="裴蜀等式"><a href="#裴蜀等式" class="headerlink" title="裴蜀等式"></a>裴蜀等式</h3><p>对于任意两个整数 ( a ) 和 ( b )，以及它们的最大公约数 ( d )，裴祖等式<strong>一定</strong>可以写成：</p>
<script type="math/tex; mode=display">
d = \gcd(a, b) = ax + by</script><p>一个重要推论: $(a, b)$ 互质的条件是存在整数 $(x, y)$ 使得 $ax + by = 1$.</p>
<h3 id="证明-1"><a href="#证明-1" class="headerlink" title="证明"></a>证明</h3><p>考虑简单形式:</p>
<script type="math/tex; mode=display">
\left \{
    \begin{aligned}
    x &\equiv a_{1} \pmod{m_{1}}  \\
    x &\equiv a_{2} \pmod{m_{2}}  \\ 
    \end{aligned}
\right.</script><p>可转化为:</p>
<script type="math/tex; mode=display">
\left \{
    \begin{aligned}
    x = ka_1 + m_1 \\
    x = ka_2 + m_2 \\ 
    \end{aligned}
\right. \\
\ \ \ \ \ \ \ \ \ \ \ \Rightarrow x = k_1 m_1 + a_1 = k_2 m_2 + a_2 \\
\Rightarrow k_1 m_1 - k_2 m_2 = a_2 - a_1</script><p>根据 $Bézout’s Identity$ 若 $ gcd(m_1, m_2) \mid a_2 - a_1 $ 则原方程有解.<br>如果有解, 设 $ d = gcd(m_1,m_2) , p_1 = \frac{m_1}{d}, p_2 = \frac{m_2}{d}$</p>
<script type="math/tex; mode=display">
\Rightarrow k_1p_1 - k_2p_2 =   \frac{ a_2 - a_1 }{d} 
\Rightarrow \frac{k_1d}{a_2 - a_1}p_1 - \frac{k_2d}{a_2-a_1}p_2 = 1;</script><p>显然 $gcd(p_1,p_2) = 1$ 可以用exgcd求解.<br>我们设该方程的一组解 $x, y$<br>$k_1 = \frac{x(a_2-a_1)}{d}, x = \frac{m_1x(a_2-a_1)}{d} + a_1$<br>原方程即转化为 :</p>
<script type="math/tex; mode=display">
    x \equiv \frac{m_1 x (a_2 - a_1)}{d} \pmod {lcm(m_1, m_2)}</script><p>我们只要把方程转化 $n - 1$ 次就可以解决问题.<br>复杂度为 $\mathcal O((n - 1)\log n)$</p>
<h1 id="Lucas定理"><a href="#Lucas定理" class="headerlink" title="Lucas定理"></a>Lucas定理</h1><p>Lucas定理用于求解大组合数取模的问题, 其中模数必须为素数.</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><script type="math/tex; mode=display">
    \binom{n}{m} \bmod p = \binom{\lfloor n / p\rfloor}{\lfloor m / p\rfloor} \cdot \binom{n \bmod p}{m \bmod p} \bmod p</script><p>对于 $  \binom{\lfloor n / p\rfloor}{\lfloor m / p\rfloor} $ 可以递归求解.</p>
<h2 id="证明-2"><a href="#证明-2" class="headerlink" title="( 证明 )"></a><del>( 证明 )</del></h2><p><del>艹我不会</del></p>
]]></content>
      <tags>
        <tag>数论</tag>
        <tag>gcd</tag>
        <tag>欧几里得算法</tag>
        <tag>中国剩余定理</tag>
      </tags>
  </entry>
  <entry>
    <title>线段树专题(动态开点线段树, 权值线段树, 线段树合并, 可持久化线段树)</title>
    <url>/2024/07/24/%E5%8A%A8%E6%80%81%E5%BC%80%E7%82%B9%E7%BA%BF%E6%AE%B5%E6%A0%91%E7%AD%89/</url>
    <content><![CDATA[<h1 id="动态开点线段树"><a href="#动态开点线段树" class="headerlink" title="动态开点线段树"></a>动态开点线段树</h1><p>动态开点线段树应用于需要维护的数列长度过大, 正常线段树存不下的时候.<br>我们需要动态的开点, 因此不能用 rt&lt;&lt;1 和 rt&lt;&lt;1|1 来表示左右子节点, 而需要在 node 中记录 lson 和 rson 的编号, 如下.</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r, val, lazy;</span><br><span class="line">&#125;st[maxn];</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>update 时如果需要开点则开点. </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> &amp;rt, <span class="type">int</span> l, <span class="type">int</span> r, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!rt) rt = ++cnt;</span><br><span class="line">    <span class="keyword">if</span>(l == r)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span>() <span class="built_in">update</span>(...);</span><br><span class="line">    <span class="keyword">if</span>() <span class="built_in">update</span>(...);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">pushup</span>(rt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>查询时同理.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> rt, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> L, <span class="type">int</span> R...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!rt) <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">if</span>(l &lt;= L &amp;&amp; R &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="权值线段树"><a href="#权值线段树" class="headerlink" title="权值线段树"></a>权值线段树</h1><p>什么是权值线段树?</p>
<blockquote>
<p>以权值为维护信息的线段树，本质仍是线段树。、</p>
</blockquote>
<p>不同于普通线段树维护的区间信息, 权值线段树维护的是固定值域内的元素的个数.<br><del>这不就是桶嘛</del></p>
<p>举个栗子<br>有个数列 $ 1, 1, 2, 2, 2, 3, 3, 4, 5 $<br>节点 $ [1, 1] $ 的值为 2 代表数列中位于 $ [1, 1] $ 的数有 2 个.<br>同理节点 $ [1, 2] $ 的值为 5 , $ [1, 5] $ 的值为 9 .</p>
<h1 id="主席树（可持久化线段树）"><a href="#主席树（可持久化线段树）" class="headerlink" title="主席树（可持久化线段树）"></a>主席树（可持久化线段树）</h1><blockquote>
<p>主席树是一种<del>霸气的</del>，持久的，基于线段树的数据结构。</p>
</blockquote>
<p>可持久化线段树, 顾名思义, 就是支持回退操作的线段树(<del>完全理解不了好不好</del>)</p>
<p>主席树由权值线段树引申而来, 可以维护区间第k小.<br>思想是开一个 root[] 数组存储 i 版本的根节点.<br>每次更新时对于需要更新的节点直接新建, 对于不需要更新的节点直接连到更新的节点上.</p>
<p>附上主席树求区间第k小代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mid ((l+r)&gt;&gt;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i, a, b) for(int i=(a); i&lt;=(b); i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 1000020</span></span><br><span class="line"><span class="type">int</span> a[maxn], b[maxn], t[maxn], n, m, k;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">str</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> l, r, val;</span><br><span class="line">&#125;tree[maxn&lt;&lt;<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> top;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>) ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) ans=(ans&lt;&lt;<span class="number">3</span>)+(ans&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>), ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">build</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> node=++top;</span><br><span class="line">	<span class="keyword">if</span>(l!=r)</span><br><span class="line">	&#123;</span><br><span class="line">		tree[node].l=<span class="built_in">build</span>(l, mid);</span><br><span class="line">		tree[node].r=<span class="built_in">build</span>(mid+<span class="number">1</span>, r);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">clone</span><span class="params">(<span class="type">int</span> node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	tree[++top]=tree[node];</span><br><span class="line">	tree[top].val++;</span><br><span class="line">	<span class="keyword">return</span> top;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">update</span><span class="params">(<span class="type">int</span> pre, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> node=<span class="built_in">clone</span>(pre);</span><br><span class="line">	<span class="keyword">if</span>(l!=r)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(x&lt;=mid)	tree[node].l=<span class="built_in">update</span>(tree[node].l, l, mid, x);</span><br><span class="line">		<span class="keyword">else</span>		tree[node].r=<span class="built_in">update</span>(tree[node].r, mid+<span class="number">1</span>, r, x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l==r)	<span class="keyword">return</span> b[l];</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> node=tree[tree[v].l].val-tree[tree[u].l].val;</span><br><span class="line">		<span class="keyword">if</span>(k&lt;=node)	<span class="keyword">return</span> <span class="built_in">query</span>(tree[u].l, tree[v].l, l, mid, k);</span><br><span class="line">		<span class="keyword">else</span>		<span class="keyword">return</span> <span class="built_in">query</span>(tree[u].r, tree[v].r, mid+<span class="number">1</span>, r, k-node);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">	<span class="built_in">rep</span>(i, <span class="number">1</span>, n) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]), b[i]=a[i];</span><br><span class="line">	<span class="built_in">sort</span>(b+<span class="number">1</span>, b+n+<span class="number">1</span>);</span><br><span class="line">	<span class="type">int</span> size=<span class="built_in">unique</span>(b+<span class="number">1</span>, b+n+<span class="number">1</span>)-(b+<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">rep</span>(i, <span class="number">1</span>, n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> x=<span class="built_in">lower_bound</span>(b+<span class="number">1</span>, b+size+<span class="number">1</span>, a[i])-b;</span><br><span class="line">		t[i]=<span class="built_in">update</span>(t[i<span class="number">-1</span>], <span class="number">1</span>, size, x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">rep</span>(i, <span class="number">1</span>, m)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> l=<span class="built_in">read</span>(), r=<span class="built_in">read</span>(), k=<span class="built_in">read</span>();</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">query</span>(t[l<span class="number">-1</span>], t[r], <span class="number">1</span>, size, k));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="线段树合并"><a href="#线段树合并" class="headerlink" title="线段树合并"></a>线段树合并</h1><p>待更</p>
<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p>待更</p>
]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>动态开点线段树</tag>
        <tag>权值线段树</tag>
        <tag>线段树合并</tag>
        <tag>可持久化线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>2024.7.24份题解</title>
    <url>/2024/07/24/2024_7_24%E4%BB%BD%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="T1-最短路"><a href="#T1-最短路" class="headerlink" title="T1 最短路"></a>T1 最短路</h1><blockquote>
<p>给定一个包含 $ n $ 个节点和 $ m $ 条边的图，每条边有一个权值。<br>你的任务是回答 $ k $ 个询问，每个询问包含两个正整数 $ s $ 和 $ t $ 表示起点和终点，要求寻找从 $ s $ 到 $ t $ 的一条路径，使得路径上权值最大的一条边权值最小。</p>
</blockquote>
<ol>
<li>最短路一定在最小生成树上</li>
<li>跑一遍 $ prim $ ，顺便更新 $ ans $</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 1020</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i, a, b) for(int i = (a); i &lt;= (b); i ++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> love return</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> you 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> me 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dist[maxn];</span><br><span class="line"><span class="type">int</span> n,m,k;</span><br><span class="line"><span class="type">int</span> cosent[maxn][maxn];</span><br><span class="line"><span class="type">int</span> ans[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> to[maxn];</span><br><span class="line"><span class="type">bool</span> f[maxn];</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;a.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;a.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(cosent, inf, <span class="built_in">sizeof</span>(cosent));</span><br><span class="line">    <span class="built_in">memset</span>(ans,<span class="number">0</span>, <span class="built_in">sizeof</span>(ans));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">0</span>, n)</span><br><span class="line">    &#123;</span><br><span class="line">        to[i] = i;</span><br><span class="line">        dist[i] = inf; </span><br><span class="line">        cosent[i][i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u, v, w;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(cosent[u][v] &gt; w)</span><br><span class="line">        &#123;</span><br><span class="line">            cosent[u][v] = cosent[v][u] = w;</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mx = inf;</span><br><span class="line">        <span class="type">int</span> v = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">rep</span>(j, <span class="number">1</span>, n) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!f[j] &amp;&amp; dist[j] &lt; mx)</span><br><span class="line">            &#123;</span><br><span class="line">                v = j;</span><br><span class="line">                mx = dist[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(v==<span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">rep</span>(j, <span class="number">1</span>, n) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(f[j])</span><br><span class="line">            &#123;</span><br><span class="line">                ans[v][j] = ans[j][v] = <span class="built_in">max</span>(ans[to[v]][j], mx);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        f[v] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="built_in">rep</span>(j, <span class="number">1</span>, n) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!f[j] &amp;&amp; cosent[v][j] &lt; dist[j])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = cosent[v][j];</span><br><span class="line">                to[j] = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u, v; cin &gt;&gt; u &gt;&gt; v; </span><br><span class="line">        cout &lt;&lt; (ans[u][v] == <span class="number">0</span> ? <span class="number">-1</span> : ans[u][v]) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    love you;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="T2-序列"><a href="#T2-序列" class="headerlink" title="T2 序列"></a>T2 序列</h1><blockquote>
<p>有一个长度为 $ n $ 的数列 $ a_1,…,a_n $, 其中对任意 $ 1 \leq i \leq n $ :<br>• 若 $ i $ 为奇数, 那么 $ a_i = \frac{i+1}{2} $.<br>• 否则 $ z_i = n + 1 - \frac{i}{2} $.<br>你需要回答q次询问, 每次询问会给定一个特定的数 $ s $, 请你求出有多少对 $ (l, r) $ 满足 $ 1 \leq l \leq r \leq n $ 且 $ \sum_{i=l}^{r}a_i = s $.</p>
</blockquote>
<p>显然当 $l, r$ 分别取奇偶, 偶奇, 奇奇, 偶偶时存在规律. </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;sequence.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;sequence.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n, q; cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">    <span class="keyword">while</span>(q --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> s; cin &gt;&gt; s;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> a = s % (n + <span class="number">1</span>), b = s % (n + <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span>(a == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans += <span class="built_in">max</span>(<span class="number">0ll</span>, n / <span class="number">2</span> - (s / (n + <span class="number">1</span>)) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a * <span class="number">2</span> - <span class="number">1</span> &lt;= n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>((a * <span class="number">2</span> - <span class="number">1</span>) - <span class="number">2</span> * (s / (n + <span class="number">1</span>)) &gt;= <span class="number">1</span>) ans ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(b == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans += <span class="built_in">max</span>(<span class="number">0ll</span>, (n - <span class="number">1</span>) / <span class="number">2</span> - (s / (n + <span class="number">2</span>)) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(b * <span class="number">2</span> - <span class="number">1</span> &gt; n) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>((n - b + <span class="number">1</span>) * <span class="number">2</span> - <span class="number">2</span> * (s / (n + <span class="number">2</span>)) &gt;= <span class="number">1</span>) ans ++;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="T3-函数"><a href="#T3-函数" class="headerlink" title="T3 函数"></a>T3 函数</h1><p>数位dp，待更</p>
<h1 id="T3-游戏"><a href="#T3-游戏" class="headerlink" title="T3 游戏"></a>T3 游戏</h1><p>nim游戏，待更</p>
]]></content>
      <tags>
        <tag>题解汇总</tag>
      </tags>
  </entry>
  <entry>
    <title>CDQ分治&amp;树状数组</title>
    <url>/2024/07/26/CDQ%E5%88%86%E6%B2%BB/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="去你妈的都说了没写完了" data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <script id="hbeData" type="hbeData" data-hmacdigest="743b6b99e41018f842315132572fd0d9f4f5f4bc587f185f9727d756dadfb938">1d2afaa8eb85c7bc19917b06306dc25500dd1f8f1b385228ceed6a12bebf3690fb1180a612ffc058a394991fcc1ee9e43bfc8fdf492712a2c821162bf5992826739fc45a4616415d5052f8b136984f04820ac3709b2ac1c19b8f0cb8ad4517a185294bb8289f2e99ba200c6d39c6461dab09a73bfe26b91f5f22a07f0a331d70b12bdd0ef31d95994cb6a240dff823140e1931178e548f9f5be0751890b68947976dc762788f0e4deb057fde43dfba60c7c1c7d6ae2473d96073f0d146b4a173a8eb4bcffea731833485b243088cd408cbb95fc3459b4efb09ebb4b9c900a5093a68c120db2b331a8ed3ade04338f816a2c98f570e656c53e3a512784797141afc6650d6fe5975b92ca118df32a0ba861e6e2d8145af7a69ec9aed99470f5db61d8bdb3d7af9d839dc155bcb220f4741d14b4b3c3565c9cffe0fdd9143f6b37718040f7b8670333e97391f41ddc3a90a4e0c414e08f4f62140b71ca49cd60eb56b09f80482dc97106aab5b29ed711073beda32469572ddf66aba6762851e50b900b63931ccd9cf4025e355dc25711b33fbd8dddaa2cd96314fb257e771e1ceaa3e67a115601bc8c5e6c714e0433d7197fcf8299a0855c088b9b65051a4e4c06ca80d7b31f57d6dcf7cde4358ac660cadf2497b52e231def3e3ccdfbc98f9d6de010b14d72a8f231f67a8b60a75e99bf18697f085219b673dfe3bb9c0c415c9ee7a243b6103e39abe93566bff894bce9ebbb2c06a694aa67dd944b0053d2aef694a04fd85210aa7b7ce602c2b0cf1ee8394590799a5ec93bd2e8d4e65d5b92c764b5826b58fc60988026ed468ee54637eb736eae5496f44bca8174fea060fc092949e8052e1afb5139296b069b2528928ffc6bae232329ae87489be05ffebae84d640885c4ff4c50686ab8d09de82483e15405e3cada1d42be3f158942cd988876276a3283cfcb8c4dca40bde41c9dfe5c411320e2f59cced116d3072167ad40acbcfe34d85f0cfb595d51cfed011723077a9130cf110605eebcb7956fa1a4e875a4577e6ebbbe797ab92689a38ea5d781c36bbf56e58792c2d9a2a5523c87d13b373b4a8f6ccaddaa35a729010a67c782a372c3f48f1f80bb6016250b96fe595e41920aec845e2134c01f36c5b64bac9e58a7919f37bcb524030a37b53cadeb511c6ecea1ef983bccc0f66708ce39488932150608604e61cda8f51281d74f89fba134892779de3aa610e5e03074227a260a8ef090ed2a934a9fdc352e0489b72db0aae4e3f5f4cf4585b4c5474e613deb6a7cf29579450ba2b6c2e7a437ca579568eecbb33d58d7d42d4bdc84cb3eda438520bd5da20ef50e70d59d25409c9d50b2bdcebd97934122b443ccb406682ecb9ccdbbda23a44621dd8c5b176df3d1ce3d8da2a03e696942bedf135c787dbb3d3fa7c61f30a729f296f0528c5b79123c3edba9fb008d32e78b8b65e6b4db2c5cdfb43a394953291164c35d2fa35a8965c06565d9cb990fdd680967bd98516393e3542e0bb3d0ec3fb6edb2d06d2bdf1a87fe1ad90af6c29d6c4ab503aa22bae06330984ffce95b8ed963ffe5baa246285de2a3ef3ef9c5b65401602119286bf2e460dfc12a4aae844558d4ba5506c17764694948c476c1cc3fe95fcc31f725f97dfd4f422ddbd6ef397953b859e70502522b1a52343a6e016c9b67aac8b58226c12a2895cbc24a670f94c36956dfea0f916a843c046df45fb4b9ced4fe90f092fd4a489dced90d369cda1d08e9203d78cadfb3e858e076a1ca95c07f03366c88648bf2bf5ea22bf5b1f5cee4f6307a2a642ad7ea6b227f13373535145e76c8692ae302bea95f53cf687d91dd369107309a05d1378bf437e288f6c5d221cc34378f22fd3ec01448bdc8461671a7f0119b97bf16dc8c3d814ac1aca1880c47a059447a1b7b29fc41e93ecac28cf306deed7cdc79512610108657ac7324357e814e0df515dcf747e5face962229441d9359bf4d8cb2956452f317b770fa278a8001a0f2a35fec8fb8303db6ba3aea70238320477b4818206fc7be4b4f5983303f1eaa6811676c5e73a0c7f1b0afd55ee5e0e45304e6ba4c9303e9daaae3f8d0d36b2557a21f996d3e96ab9d5d033af5032335ef0390f3abf78fe8b5d7ee195c0acd6a13ed4f672547c6caf9415242ff9f014644345ff375d624bf1446167baa1ce3295c7ed6c022de746359fa8f6bd355e368fc343348d0b07f3e61cd0361249fa18889c47c8dd3ddcd26927f56b0ed8a7cfd890268de6f073d0c5db933d9a563cf21ab247ec0f27dfb293679da29d884b2acd6f27a7117e9e01069ed4ede5c66379a972bca6141c0a469630e374e8f4496ee22a54c0bfad7c98f4fb9c1e74f158f90efd1d477405e22987ba28189ff8cb333a198e5b370c13e813794ede5ec0845a8581296c35a53ae9f484a19f2690ed27e7179b9a06d391eaf163151b0084d78c68b43577c13d1c60aec75e58e078deaadc38378e534af0aaeea71f0c08936537d30cd2089322397c7662e48b9b7551a67de58b3363bdc34010a6b5ed2828706be46ff8e196fcc7b4eec12990e4098595ec162524031cecc341a987af1965eff62aebfa277791fd079344804e6c32d7c0a137bcefb1fcbe6a71cced7d08ea136c89d42666f74ce98f49d5a81e07f29ea2a4fdbd62cf5966e01ff3fccb81936ce13039e2d15e3511dbdde24f7756e37227e9aad3d5ff67d1c84c8c6f528220b695836b84bef026626ca47956f7026caa0864c2dc0f58ea0e826a44d5a0cf21f5d843b37429cfcd37bdff52cd3deb69da0bdd139e9fd209a586d2a510a494ec1688640e5a2cbff2e71984271fa4e8af2af863cd55e9c9144fdf5b6be95373bececcf063dc7c26ce30a75f50968e81fc4cf8c6cf01ac39bdda02c332bc3d3a3cef7febea50835cffea326c7ed668c4855562fbfa3b686775dd14b4f4e67369f5ac70c0c109c083255d72b7100fcb0958d63d275c7263df23fcaaf85d5a8655ef96eb212e15d5945ed3869d80efa7f1699687d38da9018e08641e4d6fcdf3a15eee00e7477c18f184b1a8138a7ab295ba8992583c52fba7f112bea0b5637a1669f795fd4730c915672eb393e078f95b30dbcb6aaf6ca7a933b95bc5a7d8f6fae46f66a4194fafc12e6ea85cae2ab9e3bee6218d7986187feca5cbfd0bf6c053f4ac0706a6fedf85ed99e233580ff320d54f9d92564c64ac688f9d1c2e3e0f07b9353306d988d08864bae0335a1498c6852b38fc01696a0c26e59a0be8f7108550baf440ada6f99d94d1b9cf7f910d24e1f4a666647e6e09f671999ac6a1bf3426cb42fb2404fe56efcb543c08e6543d3b17a7779859ded828e99e3f0a0be0606b6d68947127a325d34eb30aaefa048cf48871faa822c225f067ff527a05679fb230aa0058c46e592211de32c802da4bd2bf1436ae813ded7a93f7cedad4d59bc9b4ee854ec34edf753fe8b448e7e1bc79451c5e12081e7dde1ea14f6e1d7ae116c5005498876ceb76417d5bdf4c8313aa92055a738fb03a2f1d99ad6a43f05f8ece62288f2944c54597bb62d2f12e6bb32a2ae6e921521f0478d3cc21df5a356431eb8b18037f532b7effec741bef22d84ee63a1638d39373e08e2ab880eb8875b35ff3b7749f2c8f899b5e59ee40f5a26927f39a413e903bb3316f882e235e7610c673453a7b42833929464466e6f940013dff5bf783ef57f4f9007e5dc694ba3893dcf3387311c5899e2f21d457623654c61d305e131321f2223c8ad9d635f657e6b3f1795b34e553cb5e7473c9b1f632fc127a02f4351aa9b3f567988865b8bdc402d3571236745d0a4ec13f2d8b21c787dfa9299895b1eb893f6b6ad84d15e734f6f8d6343535187921fc8d783a768c0064d9b821a8035bb7b19d0df3b8530b1ab7550886d0518fe2f28f19bce0e761f534576421269d1c482dd113cddf94c3cf4d183bba5abc9b8693c34fce1fae6172b2a6fc405de015cd5a03091a89a24f7f07574035498943d515f99fe6b17d71de4ee2dee20d6898ccece446ee2f14ff95e26b2a5746ca5c049ea0c96899f7258490b038b052e56127367feff65c1f3558b7feb4fc567215804d09915bc8fe7b44bb0c84f248ab61a335251c4f1de2a524783af945a775e4c8139193c63af10455fd5d20bcb1658de373e4db08741d132df41caae65ed1db20a5e989462f2f2091afa693a74590346aab0424ff4f7c622f77719237e5bdeed110f09244039e4cb5667a3453a60d57c600ca5248c348ee49736aeda7202f7e68c9d1909045c06cae967309396e19e8131e5e641c0ca80bd8c55e22e73361dcfc41f9b4d35ec87e017109234b6c82f0f2a61d8e4997b0c8ba81f8ac3d7bb79d8d590073e2853dd61ac773579268385f7af8426da4fbbf15737968755b525aaf87f947308bb09b78e5025c238da494abc4dc8297b8835ecfebf23f45c6a6f5a372ca3524ef1b188960fcada59b035697aec6cb8460bd9aa1864b23bca1853c18df7c001217ce540e7d6ca70e2bf4814fe7dc84c33ee9aad6599802a3d23018fa2e2fce42e1338f84320d4c0f4d99fcf6001c69a41f03deae16111c51f03dc9b3de155d30a38244c9e7c23915a125583b183d53f217872400052f401ef1e93407448cc2e973174478a9455a4608c89d7b6d2c591063487782e8bf3c6bcafc90480dfdfe772a859fbeb2c9209281d26c326edcf905dfd3f8fcbc4108e37a85dcdc2e92b500770d7e2aa8e2465fd1576230a89ece7d435de42230af671c93d0c47922407b696b5bde05c9652ffcfc925c1fdd32f8e694cdd66b540d1cdf6cd071af56a2e11bfbadf573182614897a452cefe2e828a8535135ca49c6ccaff0f34324a844942ed25a0033a26cab88fcbabd4d8f7909b77b7266de8237b773d095918fd6b917695dd326ca816b3a0d508de0ea2669a4c8c6d076c19423193b7e3e274933e4c9da5dcdc33c6cd5ecbd16a0a98721a23e63b567cb25b4ffb3ac37049c5cd5b48b06a36251c8814987315ef606ff3407e2057a7cff44f1a3aa20605acb9847bd06e8e841a5a73bd54e9013534f1754c562032e4f16193a5f97e3608d86a663a868adc3f4d320d86a19a2ef1380ea39fce2572044ad68d914c7ec1e810fe746938a8c4b1ae4e158ccbcfe9dc3d84837bc6abec53fe9a331e9e40278ad556651c887cf02126f81aa7b6257cee6edd7cc97b7be01a5049e750c9af4b1ec39e4e1ea3ffcdbd63621f106710d60a9493b048a165ac0e550ed067bdd3301ad8bd07289fff6268e0a4ca9f0a8fec3b118a7db1a444e83908589da0da3d0ca52cc62818259afc23fc039ce758f39299b450bdfe61d21e62e1d8d1a09e889feeb5fd35afc0119c8f5cc61da6380a7e0080575cb05bb0e4a85050b4687e2d2ec2c2ff51e40f57df9a0b012c100a7ee87bf6684bb3355633fc8195ca4d7d447f59053edf1d55877d49e23e8cf3abe441e8f5d0ea0f7be413bbe24b06167fa1f8a44349b7d82d4d88ef689e9c73411f71b94c7374a0814a4dc13a199cb271fefe4b31de893fe122d451a78b60b76d56b31d8237c01569f8a6325d49e141b00154d9e89d76596545713eacb8ccf50896db20a6e7a4b9af8b3b4fffb9b75641afa6065760195c5e436dc063eefc3e4431de576fd1cfae672833400d1cce2236a5def1a3db36089facb96f89234fd3b7890e46ecf7dc0e6445dae5b9eaf2744feecae65c8fe7c29b26c49b244261ded4d446b7693bc008628912be513883fc6a01fef925d4b5e4908780853a2554e8cfcf57f2d889175fb3edec963b8908606204688a1dab9ca883b50d1ef768f637f991e79993b97d188d4604565492d908b53150c9d9154c8ec6dea9ed4fc721d6c9aeda9a4534a2ebf73e614b7033ab2c646cb4078ec519f38b04dc970e62a930d1234d590f6c3fb5962bcda0dc58a</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">真没写完</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <tags>
        <tag>分治</tag>
        <tag>CDQ分治</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title>同余最短路</title>
    <url>/2024/07/29/%E5%90%8C%E4%BD%99%E6%9C%80%E7%9F%AD%E8%B7%AF/</url>
    <content><![CDATA[<h2 id="什么是同余最短路"><a href="#什么是同余最短路" class="headerlink" title="什么是同余最短路"></a>什么是同余最短路</h2><blockquote>
<p>在处理一些问题是根据数的同余关系建图, 来达到优化空间复杂度的目的.</p>
</blockquote>
<h2 id="一些经典问题"><a href="#一些经典问题" class="headerlink" title="一些经典问题"></a>一些经典问题</h2><p>诸如:</p>
<ol>
<li>给定 $n$ 个整数, 求这 $n$ 个数能拼凑出的多少其他整数 ( $n$ 个数字可以重复取).</li>
<li>给定 $n$ 个整数, 求这 $n$ 个数不能拼凑出的 最大/最小 的整数.</li>
<li>至少需要拼几次才可以拼出模 $k$ 余 $b$ 的数.</li>
</ol>
<p>详细解释在例题中给出.</p>
<blockquote>
<p>做题是最好的学习 <del>(不是)</del></p>
</blockquote>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="一-简单不等式"><a href="#一-简单不等式" class="headerlink" title="一. 简单不等式"></a>一. 简单不等式</h3><blockquote>
<p>给定长度为 $n$ 的正整数序列 $A$ , 请问有多少个整数属于 $[l, r]$, 可以表示为形如</p>
<script type="math/tex; mode=display">T = \Sigma_{i = 1}^{n}(a_i \times p_i)</script><p>其中 $P$ 为你构造的任意非负整数序列.</p>
</blockquote>
<h6 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h6><blockquote>
<p>input1</p>
<blockquote>
<p>2 5 10<br>3 5</p>
</blockquote>
<p>output1</p>
<blockquote>
<p>5</p>
</blockquote>
<p>input2</p>
<blockquote>
<p>3 101 100000000<br>99 23333 66666</p>
</blockquote>
<p>output2</p>
<blockquote>
<p>99573689</p>
<h6 id="数据范围与提示"><a href="#数据范围与提示" class="headerlink" title="数据范围与提示"></a>数据范围与提示</h6><p>$ 1 \leq n \leq 12 $, $1 \leq l \leq r \leq 10^{12} $, $1 \leq a_i \leq 2 \times 10^5 $</p>
</blockquote>
</blockquote>
<p>见到求区间答案的这种题首先考虑考虑是否可以差分, 用 $ solve(x) $ 表示 $1 \to x$ 的答案, $ l \to r $ 就是 $ solve(r) - solve(l - 1) $.</p>
<p>再看题目, 此题等价于 “给定 n 个整数, 求这 n 个数能拼凑出的多少其他整数 (n个数字可以重复取).”<br>我们记录 $ mn = min(a_i) $, 构造在 余 mn 意义下的最短路, 在 $i \in [0, mn) $ 与 $ (i + a[j]) \% mn $ 之间连单向边, 边权为 $a[j]$ , 意思是从 $ i $ 加到 $ (i + a[j]) $ 在模 $ mn $ 意义下需要的代价为 $a[j]$. (一定要注意都是在模 $k$ 意义下!!!!<del>感性</del>理解理解) , 而我们从 0 跑到 $i \in [0, mn) $ 的最短路(所花费的代价)就是 $T$ , 而且 $T + k\cdot mn$ 也是答案之一.<br>因此对于 $ 0 \to i \in [0, mn) $ 的最短路 $dis[i]$  对 [1, x] 的贡献为:</p>
<script type="math/tex; mode=display">
ans = sigma_{i = 0}^{mn - 1} \frac{(x - dis[i])}{mn} + 1</script><p>加一是因为 $dis[i]$ 本身就是一个答案.<br>分数在计算 $T + k\cdot mn$ 的个数.</p>
<p>附上代码, 也有详细解释.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i, a, b) for(int i = (a); i &lt;= (b); i ++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 1000001</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> love return </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> you 0</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, l, r;<span class="comment">//三输入</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">30</span>], mn = inf;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> head[maxn], nxt[maxn], dat[maxn], val[maxn], cnt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dat[++ cnt] = v; nxt[cnt] = head[u]; head[u] = cnt; val[cnt] = w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> u, val;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> node&amp; a) <span class="type">const</span> &#123;<span class="keyword">return</span> val &gt; a.val; &#125; <span class="comment">//优先队列从小到大排序</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dis[maxn];</span><br><span class="line"><span class="type">bool</span> vis[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tj</span><span class="params">(<span class="type">int</span> x)</span><span class="comment">//最短路</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    priority_queue &lt; node &gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;<span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = q.<span class="built_in">top</span>().u, k = q.<span class="built_in">top</span>().val;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(vis[u] &amp;&amp; dis[u] != k)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">        vis[u] = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = head[u]; i; i = nxt[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> t = dat[i], w = val[i];</span><br><span class="line">            <span class="keyword">if</span>(dis[t] &gt; dis[u] + w)</span><br><span class="line">            &#123;</span><br><span class="line">                dis[t] = dis[u] + w;</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;t, dis[t]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    love ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">value</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">0</span>, mn - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dis[i] &lt;= x)<span class="comment">//注意dis[j] 超过 x 的话就不用计算了</span></span><br><span class="line">            res += (x - dis[i]) / mn + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    love res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;a.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;a.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; l &gt;&gt; r;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        mn = <span class="built_in">min</span>(a[i], mn);<span class="comment">//找到最小值, 使复杂度最小</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">0</span>, mn - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">rep</span>(j, <span class="number">1</span>, n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j] == mn) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">add</span>(i, (i + a[j]) % mn, a[j]);<span class="comment">//建边</span></span><br><span class="line">        &#125;</span><br><span class="line">        dis[i] = inf; </span><br><span class="line">    &#125;dis[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">tj</span>(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="built_in">value</span>(r) - <span class="built_in">value</span>(l - <span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    love you; <span class="comment">//:D</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h6 id="luogu简化版本P3403-刷经验"><a href="#luogu简化版本P3403-刷经验" class="headerlink" title="luogu简化版本P3403.刷经验"></a><a href="https://www.luogu.com.cn/problem/P3403">luogu简化版本P3403.</a><del>刷经验</del></h6><p>附上代码<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i, a, b) for(int i = (a); i &lt;= (b); i ++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 500001</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> love return </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> you 0</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, l, r;<span class="comment">//三输入</span></span><br><span class="line"><span class="type">int</span> mn = inf;</span><br><span class="line">ll h;</span><br><span class="line"><span class="type">int</span> a, b, c; </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> head[maxn], nxt[maxn], dat[maxn], val[maxn], cnt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dat[++ cnt] = v; nxt[cnt] = head[u]; head[u] = cnt; val[cnt] = w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> u, val;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> node&amp; a) <span class="type">const</span> &#123;<span class="keyword">return</span> val &gt; a.val; &#125; <span class="comment">//优先队列从小到大排序</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> dis[maxn];</span><br><span class="line"><span class="type">bool</span> vis[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tj</span><span class="params">()</span><span class="comment">//最短路</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    priority_queue &lt; node &gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;<span class="number">1</span>, <span class="number">1</span>&#125;);dis[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = q.<span class="built_in">top</span>().u, k = q.<span class="built_in">top</span>().val;</span><br><span class="line">        q.<span class="built_in">pop</span>(); </span><br><span class="line">        <span class="keyword">if</span>(dis[u] != k &amp;&amp; vis[u])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">        vis[u] = <span class="number">1</span>;  </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = head[u]; i; i = nxt[i])</span><br><span class="line">        &#123; </span><br><span class="line">            <span class="type">int</span> t = dat[i], w = val[i]; </span><br><span class="line">            <span class="keyword">if</span>(dis[t] &gt; dis[u] + w)</span><br><span class="line">            &#123;</span><br><span class="line">                dis[t] = dis[u] + w;</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;t, dis[t]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    love ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">value</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">0</span>, a - <span class="number">1</span>)</span><br><span class="line">    &#123; </span><br><span class="line">        <span class="comment">// cout &lt;&lt; dis[i] &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">if</span>(dis[i] &lt;= x)<span class="comment">//注意dis[j] 超过 x 的话就不用计算了</span></span><br><span class="line">            res += (x - dis[i]) / a + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    love res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;a.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;a.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">    cin &gt;&gt; h &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">    <span class="keyword">if</span>(a == <span class="number">1</span> || b == <span class="number">1</span> || c == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; h &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; a; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">add</span>(i, (i + b) % a, b);</span><br><span class="line">        <span class="built_in">add</span>(i, (i + c) % a, c);</span><br><span class="line">        dis[i] = <span class="number">18446744073709551610</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">tj</span>();</span><br><span class="line">    cout &lt;&lt; <span class="built_in">value</span>(h) &lt;&lt; endl;</span><br><span class="line">    love you; <span class="comment">//:D</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>Dijkstra</tag>
        <tag>最短路</tag>
        <tag>同余最短路</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>扫描线</title>
    <url>/2024/07/24/%E6%89%AB%E6%8F%8F%E7%BA%BF/</url>
    <content><![CDATA[<p>from OI-WIKI</p>
<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>在二维坐标系上，给出多个矩形的左下以及右上坐标，求出所有矩形构成的图形的面积。</p>
<h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><p>现在假设我们有一根线，从下往上开始扫描：<br><del>(图片)</del></p>
<ol>
<li>如图所示，我们可以把整个矩形分成如图各个颜色不同的小矩形，那么这个小矩形的高就是我们扫过的距离，那么剩下了一个变量，那就是矩形的长一直在变化。</li>
<li>我们的线段树就是为了维护矩形的长，我们给每一个矩形的上下边进行标记，下面的边标记为 $1$，上面的边标记为 $-1$，每遇到一个矩形时，我们知道了标记为 $1$ 的边，我们就加进来这一条矩形的长，等到扫描到 $-1$ 时，证明这一条边需要删除，就删去，利用 $1$ 和 $-1$ 可以轻松的到这种状态。</li>
<li>还要注意这里的线段树指的并不是线段的一个端点，而指的是一个区间，所以我们要计算的是 $r+1$ 和 $r-1$。</li>
<li>需要 离散化。</li>
</ol>
<p>附上代码及注释：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 1000020</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i, a, b) for(int i = (a); i &lt;= (b); i ++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lson (rt&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rson (rt&lt;&lt;1|1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mid ((l+r)&gt;&gt;1)</span></span><br><span class="line"><span class="comment">//记得加括号（（</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> love return</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> you 0</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> segment_tree</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l, r, len, sum;</span><br><span class="line">        <span class="comment">//记录节点的左端点，右端点，此点对应的长度，以及我们需要增加总长度还是减小总长度（是矩形的靠前边否）</span></span><br><span class="line">    &#125;st[maxn&lt;&lt;<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">segment</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l, r, h, vul; </span><br><span class="line">        <span class="comment">//记录此线段的左端点右端点，高度和靠前边否</span></span><br><span class="line">    &#125;segg[maxn&lt;&lt;<span class="number">2</span>];</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(segment a, segment b)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        love a.h &lt; b.h;</span><br><span class="line">        <span class="comment">//我们需要将边按照高度排序</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> X[maxn];</span><br><span class="line">    <span class="comment">//记录线段树中需要存储的点（不相同的点）</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> rt)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(st[rt].sum)</span><br><span class="line">        &#123;</span><br><span class="line">            st[rt].len = X[st[rt].r + <span class="number">1</span>] - X[st[rt].l];</span><br><span class="line">            <span class="comment">//当被完全覆盖的节点需要改变时改变</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            st[rt].len = st[lson].len + st[rson].len;</span><br><span class="line">            <span class="comment">//不是被完全覆盖的节点或者此节点没有贡献</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        love ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> rt, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        st[rt].l = l; st[rt].r = r;</span><br><span class="line">        st[rt].len = <span class="number">0</span>; st[rt].sum = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">if</span>(l == r) </span><br><span class="line">        &#123;</span><br><span class="line">            love ;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="built_in">build</span>(lson, l, mid);</span><br><span class="line">        <span class="built_in">build</span>(rson, mid + <span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">        love ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> rt, <span class="type">int</span> al_l, <span class="type">int</span> al_r, <span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = st[rt].l, r = st[rt].r;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(X[l] &gt;= al_r || X[r + <span class="number">1</span>] &lt;= al_l) love ;</span><br><span class="line">        <span class="comment">//剪枝</span></span><br><span class="line">        <span class="keyword">if</span>(X[l] &gt;= al_l &amp;&amp; X[r + <span class="number">1</span>] &lt;= al_r)</span><br><span class="line">        &#123;</span><br><span class="line">            st[rt].sum += val;</span><br><span class="line">            <span class="comment">//如果此节点被完全覆盖</span></span><br><span class="line">            <span class="built_in">pushup</span>(rt);</span><br><span class="line">            <span class="comment">//在此时就回传</span></span><br><span class="line">            love ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">update</span>(lson, al_l, al_r, val);</span><br><span class="line">        <span class="built_in">update</span>(rson, al_l, al_r, val);</span><br><span class="line">        <span class="built_in">pushup</span>(rt);</span><br><span class="line">        <span class="comment">//回传</span></span><br><span class="line">        love ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">1</span>, n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x1, y1, x2, y2; cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2;</span><br><span class="line">            <span class="comment">//输入</span></span><br><span class="line">            segg[(i &lt;&lt; <span class="number">1</span>) - <span class="number">1</span>] = (segment)&#123;x1, x2, y1, <span class="number">1</span>&#125;;</span><br><span class="line">            segg[(i &lt;&lt; <span class="number">1</span>)]     = (segment)&#123;x1, x2, y2, <span class="number">-1</span>&#125;;</span><br><span class="line">            <span class="comment">//我们需要存n*2条边，这里的处理只是为了存储恰好为n*2，没有有顺序的意思</span></span><br><span class="line">            X[(i &lt;&lt; <span class="number">1</span>) - <span class="number">1</span>] = x1;</span><br><span class="line">            X[(i &lt;&lt; <span class="number">1</span>)] = x2;</span><br><span class="line">            <span class="comment">//存点</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        n &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">sort</span>(segg + <span class="number">1</span>, segg + <span class="number">1</span> + n, cmp);</span><br><span class="line">        <span class="built_in">sort</span>(X + <span class="number">1</span>, X + n + <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> cnt = <span class="built_in">unique</span>(X + <span class="number">1</span>, X + n + <span class="number">1</span>) - X - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//去重函数，重点记忆！</span></span><br><span class="line">        <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, cnt - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//建树</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// rep(i, 1, n) cout &lt;&lt; segg[i].h &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">// rep(i, 1, n) cout &lt;&lt; X[i] &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">1</span>, n - <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">update</span>(<span class="number">1</span>, segg[i].l, segg[i].r, segg[i].vul); </span><br><span class="line">            ans += st[<span class="number">1</span>].len * (segg[i + <span class="number">1</span>].h - segg[i].h);</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">        love you;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;a.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;a.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    segment_tree::<span class="built_in">main</span>();</span><br><span class="line"></span><br><span class="line">    love you;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>一道例题 <a href="https://luogu.com.cn/problem/P1502">P1502</a></p>
<p>附上<del>我也不知道怎么对</del>的代码。。。<br><del>回头再调</del></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">// #define int long long</span><br><span class="line">#define rep(i, a, b) for(int i = (a); i &lt;= (b); i ++)</span><br><span class="line">#define lson (rt&lt;&lt;1)</span><br><span class="line">#define rson (rt&lt;&lt;1|1)</span><br><span class="line">// #define mi ((l+r)&gt;&gt;1)</span><br><span class="line">#define maxn 300010</span><br><span class="line">#define int long long</span><br><span class="line">#define love return</span><br><span class="line">#define you 0</span><br><span class="line">int T, n, w, h, C[maxn];</span><br><span class="line">// 组数，元素个数，宽，高</span><br><span class="line"></span><br><span class="line">// namespace line_sweep</span><br><span class="line">// &#123;</span><br><span class="line">    // int C[maxn&lt;&lt;2];</span><br><span class="line">    //存横坐标</span><br><span class="line">    struct segment&#123;</span><br><span class="line">        int l,r,h;</span><br><span class="line">        int val;</span><br><span class="line">        bool operator &lt;(const segment &amp;a)const&#123;</span><br><span class="line">            return (h!=a.h)?h&lt;a.h:val&gt;a.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;segg[maxn&lt;&lt;2];</span><br><span class="line">    struct node&#123;</span><br><span class="line">        int l,r;</span><br><span class="line">        int mx,add;</span><br><span class="line">    &#125;st[maxn&lt;&lt;2];</span><br><span class="line"></span><br><span class="line">    void pushup(int rt)</span><br><span class="line">    &#123;</span><br><span class="line">        st[rt].mx = max(st[lson].mx, st[rson].mx);    </span><br><span class="line">        //上推</span><br><span class="line">        love ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void pushdown(int rt)</span><br><span class="line">    &#123;</span><br><span class="line">        st[lson].mx += st[rt].add;</span><br><span class="line">        st[rson].mx += st[rt].add;</span><br><span class="line">        st[lson].add += st[rt].add;</span><br><span class="line">        st[rson].add += st[rt].add;</span><br><span class="line"></span><br><span class="line">        st[rt].add = 0;</span><br><span class="line">        //下推</span><br><span class="line">        love ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void build(int rt, int l, int r)//建树</span><br><span class="line">    &#123;</span><br><span class="line">        st[rt].l = l, st[rt].r = r;</span><br><span class="line">        st[rt].add = 0; st[rt].mx = 0;</span><br><span class="line">        if(l == r) love ;</span><br><span class="line">        int mi = (l+r)&gt;&gt;1;</span><br><span class="line">        build(lson, l, mi);</span><br><span class="line">        build(rson, mi + 1, r);</span><br><span class="line">    &#125;</span><br><span class="line">    // void build(int x,int l,int r)&#123;</span><br><span class="line">    //     st[x].l=l,st[x].r=r,st[x].mx=st[x].add=0;</span><br><span class="line">    //     if(l==r)return;</span><br><span class="line">    //     int mi=(l+r)&gt;&gt;1;</span><br><span class="line">    //     build(x&lt;&lt;1,l,mi);</span><br><span class="line">    //     build(x&lt;&lt;1|1,mi+1,r);</span><br><span class="line">    // &#125;</span><br><span class="line"></span><br><span class="line">    void update(int rt, int al_l, int al_r, int val)//上传</span><br><span class="line">    &#123;</span><br><span class="line">        int l = st[rt].l, r = st[rt].r;</span><br><span class="line">        if(l &gt;= al_l &amp;&amp; r &lt;= al_r)</span><br><span class="line">        &#123;</span><br><span class="line">            st[rt].mx += val;</span><br><span class="line">            st[rt].add += val;</span><br><span class="line">            love ;</span><br><span class="line">        &#125;</span><br><span class="line">        pushdown(rt);</span><br><span class="line">        </span><br><span class="line">	    int mi=(l+r)&gt;&gt;1;</span><br><span class="line">        if(al_l &lt;= mi)update(lson, al_l, al_r, val);</span><br><span class="line">        if(al_r &gt; mi)update(rson, al_l, al_r, val);</span><br><span class="line">        pushup(rt);</span><br><span class="line">    &#125;</span><br><span class="line">    void init()//初始化</span><br><span class="line">    &#123;</span><br><span class="line">        memset(segg, 0, sizeof(segg));</span><br><span class="line">        memset(st, 0, sizeof(st));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // signed main()</span><br><span class="line">    // &#123;</span><br><span class="line">    //     init();</span><br><span class="line">    //     rep(i, 1, n)</span><br><span class="line">    //     &#123;</span><br><span class="line">    //         int x, y, v; cin &gt;&gt; x &gt;&gt; y &gt;&gt; v;</span><br><span class="line">    //         C[(i &lt;&lt; 1) - 1] = y; </span><br><span class="line">    //         C[(i &lt;&lt; 1)] = y + h - 1;</span><br><span class="line">    //         segg[(i &lt;&lt; 1) - 1] = (segment)&#123;y, y + h - 1, x, v&#125;;</span><br><span class="line">    //         segg[(i &lt;&lt; 1)] = (segment)&#123;y, y + h - 1, x + w - 1, -v&#125;;</span><br><span class="line">    //     &#125;</span><br><span class="line"></span><br><span class="line">    //     n &lt;&lt;= 1;</span><br><span class="line"></span><br><span class="line">    //     sort(segg + 1, segg + n + 1);</span><br><span class="line">    //     sort(X + 1, X + n + 1);</span><br><span class="line">    //     int cnt = unique(X + 1, X + n + 1) - (X + 1);</span><br><span class="line"></span><br><span class="line">    //     rep(i, 1, n)</span><br><span class="line">    //     &#123;</span><br><span class="line">    //         int pos1 = lower_bound(X + 1, X + cnt + 1, segg[i].l) - X;</span><br><span class="line">    //         int pos2 = lower_bound(X + 1, X + cnt + 1, segg[i].r) - X;</span><br><span class="line">    //         segg[i].r = pos2; </span><br><span class="line">    //         segg[i].l = pos1;</span><br><span class="line">    //     &#125;</span><br><span class="line"></span><br><span class="line">    //     build(1, 1, cnt);</span><br><span class="line"></span><br><span class="line">    //     int ans = 0;</span><br><span class="line"></span><br><span class="line">    //     rep(i, 1, n)</span><br><span class="line">    //     &#123;</span><br><span class="line">    //         update(1, segg[i].l, segg[i].r, segg[i].val);</span><br><span class="line">    //         ans = max(ans, st[1].mx);</span><br><span class="line">    //     &#125;</span><br><span class="line"></span><br><span class="line">    //     cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        // love you;</span><br><span class="line">    // &#125;</span><br><span class="line">// &#125;</span><br><span class="line"></span><br><span class="line">signed main()</span><br><span class="line">&#123;</span><br><span class="line">    // freopen(&quot;a.in&quot;, &quot;r&quot;, stdin);</span><br><span class="line">    // freopen(&quot;a.out&quot;, &quot;w&quot;, stdout);</span><br><span class="line">    // cin &gt;&gt; T;</span><br><span class="line">    // while(T --)</span><br><span class="line">    // &#123;</span><br><span class="line">// 3 5 4</span><br><span class="line">// 1 2 3</span><br><span class="line">// 2 3 2</span><br><span class="line">// 6 3 1</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; w &gt;&gt; h;</span><br><span class="line">        // init();</span><br><span class="line">        rep(i, 1, n)</span><br><span class="line">        &#123;</span><br><span class="line">            int x, y, v; cin &gt;&gt; x &gt;&gt; y &gt;&gt; v;</span><br><span class="line">            C[(i &lt;&lt; 1) - 1] = y; </span><br><span class="line">            C[(i &lt;&lt; 1)] = y + h - 1;</span><br><span class="line">            segg[(i &lt;&lt; 1) - 1] = (segment)&#123;y, y + h - 1, x, v&#125;;</span><br><span class="line">            segg[(i &lt;&lt; 1)] = (segment)&#123;y, y + h - 1, x + w - 1, -v&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        n &lt;&lt;= 1;</span><br><span class="line"></span><br><span class="line">        sort(segg + 1, segg + n + 1);</span><br><span class="line">        sort(C + 1, C + n + 1);</span><br><span class="line">        int cnt = unique(C + 1, C + n + 1) - (C + 1);</span><br><span class="line"></span><br><span class="line">        rep(i, 1, n)</span><br><span class="line">        &#123;</span><br><span class="line">            int pos1 = lower_bound(C + 1, C + cnt + 1, segg[i].l) - C;</span><br><span class="line">            int pos2 = lower_bound(C + 1, C + cnt + 1, segg[i].r) - C;</span><br><span class="line">            segg[i].r = pos2; </span><br><span class="line">            segg[i].l = pos1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        build(1, 1, cnt);</span><br><span class="line"></span><br><span class="line">        int ans = 0;</span><br><span class="line"></span><br><span class="line">        rep(i, 1, n)</span><br><span class="line">        &#123;</span><br><span class="line">            update(1, segg[i].l, segg[i].r, segg[i].val);</span><br><span class="line">            ans = max(ans, st[1].mx);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">        // line_sweep::main();</span><br><span class="line">    // &#125;</span><br><span class="line"></span><br><span class="line">    love you;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>扫描线</tag>
      </tags>
  </entry>
  <entry>
    <title>最长公共上升子序列(LCIS)</title>
    <url>/2024/07/25/%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h2 id="什么是最长公共上升子序列-bushi"><a href="#什么是最长公共上升子序列-bushi" class="headerlink" title="什么是最长公共上升子序列(bushi)"></a>什么是最长公共上升子序列(bushi)</h2><blockquote>
<p>最长公共上升子序列就是最长的公共的上升的子序列(子序列不需要连续哦)</p>
</blockquote>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><h4 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h4><p>显然考虑dp, $ dp_{i,j} $ 表示选取序列 a 的前 i 个元素, lcis以 $ b_i $ 结尾的最长公共子序列的长度</p>
<h4 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h4><ol>
<li>$ a_i \neq b_i $ : $ dp_{i, j} \gets dp_{i - 1, j} $<br>//如果 $ a_i \neq b_i $ , 那么在以 $ b_i $ 结尾的公共子序列中一定不选 $ a_i $</li>
<li>$ a_i = b_i $ : $ dp_{i, j} \gets max(dp_{i - 1, k}), k &lt; j $<br>////如果 $ b_k $小于 $ b_j $, 那么便可由 $ b_k $ 转移, 注意 $ a_i $ 已经和 $ b_i $ 配对所以不考虑</li>
</ol>
<p>附上代码:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 100020</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i, a, b) for(int i = (a); i &lt;= (b); i ++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> love return</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> you 0</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dp[<span class="number">5001</span>][<span class="number">5001</span>];</span><br><span class="line"><span class="type">int</span> a[maxn], b[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;a.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;a.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n, m; cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) cin &gt;&gt; a[i];</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    <span class="built_in">rep</span>(j, <span class="number">1</span>, m) cin &gt;&gt; b[j];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// rep(i, 1, n) cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;;</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// rep(i, 1, m) cout &lt;&lt; b[i] &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">rep</span>(j, <span class="number">1</span>, m)</span><br><span class="line">        &#123; </span><br><span class="line">            dp[i][j] = dp[i - <span class="number">1</span>][j]; <span class="comment">//如果a_i != b_i, 那么在以b_i结尾的公共子序列中一定不选a_i</span></span><br><span class="line">            <span class="keyword">if</span>(a[i] == b[j])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> mx = <span class="number">0</span>;</span><br><span class="line">                <span class="built_in">rep</span>(k, <span class="number">1</span>, j - <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(b[k] &lt; b[j])</span><br><span class="line">                    &#123;</span><br><span class="line">                        mx = <span class="built_in">max</span>(mx, dp[i - <span class="number">1</span>][k]); <span class="comment">//如果b[k]小于b[i], 那么便可由b[k]转移, 注意a_i已经和b_i配对所以不考虑</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                mx += <span class="number">1</span>;</span><br><span class="line">                dp[i][j] = mx;</span><br><span class="line">            &#125;    </span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, m) ans = <span class="built_in">max</span>(ans, dp[n][i]);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    love you;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>但考虑到最坏情况下复杂度会退化到 $ O(n^3) $,  所以有没有什么方案可以再进一步降低复杂度呢?</p>
<p>我们可以发现 $ a_i = b_j, b_j &gt; b_k $ 和 $ a_i &gt; b_j $ 是等价的.</p>
<p>所以在第二层循环中只需要记一个 mxdp 来维护当前 $ dp_{i, j} 的最大值就好</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 100020</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i, a, b) for(int i = (a); i &lt;= (b); i ++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> love return</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> you 0</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dp[<span class="number">5001</span>][<span class="number">5001</span>];</span><br><span class="line"><span class="type">int</span> a[maxn], b[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;a.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;a.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n, m; cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) cin &gt;&gt; a[i];</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    <span class="built_in">rep</span>(j, <span class="number">1</span>, m) cin &gt;&gt; b[j]; </span><br><span class="line"></span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mx = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">rep</span>(j, <span class="number">1</span>, m)</span><br><span class="line">        &#123; </span><br><span class="line">            dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">if</span>(a[i] &gt; b[j]) mx = <span class="built_in">max</span>(mx, dp[i][j]);</span><br><span class="line">            <span class="keyword">if</span>(a[i] == b[j]) dp[i][j] = mx + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, m) ans = <span class="built_in">max</span>(ans, dp[n][i]);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    love you;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><del>显然还可以使用滚动数组优化空间, 但滚动数组我不想写</del></p>
<h1 id="寄"><a href="#寄" class="headerlink" title="寄"></a>寄</h1>]]></content>
      <tags>
        <tag>动态规划</tag>
        <tag>最长公共子序列</tag>
        <tag>最长公共上升子序列</tag>
      </tags>
  </entry>
  <entry>
    <title>失眠的信</title>
    <url>/2024/07/25/%E6%9D%82%E5%BF%B5/</url>
    <content><![CDATA[<p>这会是一个不眠的夜吗？</p>
<p>望着无光晦暗的天花板，有人彷徨迷茫，有人无助忧伤。</p>
<p>那就请转头看看窗外吧，看看繁星为谁而闪烁，看看明月为谁而高悬。</p>
<p>去看看不灭的城市中车流穿梭，编织着无数失眠的梦想；去看看楼房的窗户里灯光常亮，浸染着数不清的纸短情长。</p>
<p>不要忘记了，在这个世界上还有许多人将会与你遇见，还有许多人正等待着被你遇见。</p>
<p>城市万家灯火，总有一盏为你而开；世间繁华万千，总有一种为你而来。</p>
<p>失眠的人啊，</p>
<p>请安心睡去。</p>
<p>因为，</p>
<p>明天就在那里。</p>
]]></content>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
</search>
