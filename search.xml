<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2024.7.24份题解</title>
    <url>/2024/07/24/2024_7_24%E4%BB%BD%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="T1-最短路"><a href="#T1-最短路" class="headerlink" title="T1 最短路"></a>T1 最短路</h1><blockquote>
<p>给定一个包含 $ n $ 个节点和 $ m $ 条边的图，每条边有一个权值。<br>你的任务是回答 $ k $ 个询问，每个询问包含两个正整数 $ s $ 和 $ t $ 表示起点和终点，要求寻找从 $ s $ 到 $ t $ 的一条路径，使得路径上权值最大的一条边权值最小。</p>
</blockquote>
<ol>
<li>最短路一定在最小生成树上</li>
<li>跑一遍 $ prim $ ，顺便更新 $ ans $</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 1020</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i, a, b) for(int i = (a); i &lt;= (b); i ++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> love return</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> you 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> me 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dist[maxn];</span><br><span class="line"><span class="type">int</span> n,m,k;</span><br><span class="line"><span class="type">int</span> cosent[maxn][maxn];</span><br><span class="line"><span class="type">int</span> ans[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> to[maxn];</span><br><span class="line"><span class="type">bool</span> f[maxn];</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;a.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;a.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(cosent, inf, <span class="built_in">sizeof</span>(cosent));</span><br><span class="line">    <span class="built_in">memset</span>(ans,<span class="number">0</span>, <span class="built_in">sizeof</span>(ans));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">0</span>, n)</span><br><span class="line">    &#123;</span><br><span class="line">        to[i] = i;</span><br><span class="line">        dist[i] = inf; </span><br><span class="line">        cosent[i][i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u, v, w;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(cosent[u][v] &gt; w)</span><br><span class="line">        &#123;</span><br><span class="line">            cosent[u][v] = cosent[v][u] = w;</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mx = inf;</span><br><span class="line">        <span class="type">int</span> v = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">rep</span>(j, <span class="number">1</span>, n) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!f[j] &amp;&amp; dist[j] &lt; mx)</span><br><span class="line">            &#123;</span><br><span class="line">                v = j;</span><br><span class="line">                mx = dist[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(v==<span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">rep</span>(j, <span class="number">1</span>, n) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(f[j])</span><br><span class="line">            &#123;</span><br><span class="line">                ans[v][j] = ans[j][v] = <span class="built_in">max</span>(ans[to[v]][j], mx);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        f[v] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="built_in">rep</span>(j, <span class="number">1</span>, n) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!f[j] &amp;&amp; cosent[v][j] &lt; dist[j])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = cosent[v][j];</span><br><span class="line">                to[j] = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u, v; cin &gt;&gt; u &gt;&gt; v; </span><br><span class="line">        cout &lt;&lt; (ans[u][v] == <span class="number">0</span> ? <span class="number">-1</span> : ans[u][v]) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    love you;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="T2-序列"><a href="#T2-序列" class="headerlink" title="T2 序列"></a>T2 序列</h1><blockquote>
<p>有一个长度为 $ n $ 的数列 $ a_1,…,a_n $, 其中对任意 $ 1 \leq i \leq n $ :<br>• 若 $ i $ 为奇数, 那么 $ a_i = \frac{i+1}{2} $.<br>• 否则 $ z_i = n + 1 - \frac{i}{2} $.<br>你需要回答q次询问, 每次询问会给定一个特定的数 $ s $, 请你求出有多少对 $ (l, r) $ 满足 $ 1 \leq l \leq r \leq n $ 且 $ \sum_{i=l}^{r}a_i = s $.</p>
</blockquote>
<p>显然当 $l, r$ 分别取奇偶, 偶奇, 奇奇, 偶偶时存在规律. </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;sequence.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;sequence.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n, q; cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">    <span class="keyword">while</span>(q --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> s; cin &gt;&gt; s;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> a = s % (n + <span class="number">1</span>), b = s % (n + <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span>(a == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans += <span class="built_in">max</span>(<span class="number">0ll</span>, n / <span class="number">2</span> - (s / (n + <span class="number">1</span>)) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a * <span class="number">2</span> - <span class="number">1</span> &lt;= n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>((a * <span class="number">2</span> - <span class="number">1</span>) - <span class="number">2</span> * (s / (n + <span class="number">1</span>)) &gt;= <span class="number">1</span>) ans ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(b == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans += <span class="built_in">max</span>(<span class="number">0ll</span>, (n - <span class="number">1</span>) / <span class="number">2</span> - (s / (n + <span class="number">2</span>)) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(b * <span class="number">2</span> - <span class="number">1</span> &gt; n) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>((n - b + <span class="number">1</span>) * <span class="number">2</span> - <span class="number">2</span> * (s / (n + <span class="number">2</span>)) &gt;= <span class="number">1</span>) ans ++;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="T3-函数"><a href="#T3-函数" class="headerlink" title="T3 函数"></a>T3 函数</h1><p>数位dp，待更</p>
<h1 id="T3-游戏"><a href="#T3-游戏" class="headerlink" title="T3 游戏"></a>T3 游戏</h1><p>nim游戏，待更</p>
]]></content>
      <tags>
        <tag>题解汇总</tag>
      </tags>
  </entry>
  <entry>
    <title>CDQ分治&amp;树状数组</title>
    <url>/2024/07/26/CDQ%E5%88%86%E6%B2%BB/</url>
    <content><![CDATA[<h1 id="偏序关系"><a href="#偏序关系" class="headerlink" title="偏序关系"></a>偏序关系</h1><blockquote>
<p>设R是集合A上的一个关系, 如果R是自反的, 反对称的, 传递的; 则称R为一个偏序关系(也叫部分序关系或半序关系).<br>(就是 $ a_i &lt; b_j $ )?</p>
</blockquote>
<h1 id="一维偏序"><a href="#一维偏序" class="headerlink" title="一维偏序"></a>一维偏序</h1><blockquote>
<p>给你一个长度为 n 的序列, 求出每个元素在序列中比其小的元素的个数.<br>这是最基础的偏序问题, 直接 sort 去重处理即可</p>
</blockquote>
<h1 id="二维偏序"><a href="#二维偏序" class="headerlink" title="二维偏序"></a>二维偏序</h1><p>&gt;</p>
]]></content>
      <tags>
        <tag>分治</tag>
        <tag>CDQ分治</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title>hello world twice</title>
    <url>/2024/06/03/hello-world-twice/</url>
    <content><![CDATA[<p><del>这里记下一点杂谈吧</del></p>
<h1 id="2024-7-24"><a href="#2024-7-24" class="headerlink" title="2024/7/24"></a>2024/7/24</h1>]]></content>
      <tags>
        <tag>建立博客</tag>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title>线段树专题(动态开点线段树, 权值线段树, 线段树合并, 可持久化线段树)</title>
    <url>/2024/07/24/%E5%8A%A8%E6%80%81%E5%BC%80%E7%82%B9%E7%BA%BF%E6%AE%B5%E6%A0%91%E7%AD%89/</url>
    <content><![CDATA[<h1 id="动态开点线段树"><a href="#动态开点线段树" class="headerlink" title="动态开点线段树"></a>动态开点线段树</h1><p>动态开点线段树应用于需要维护的数列长度过大, 正常线段树存不下的时候.<br>我们需要动态的开点, 因此不能用 rt&lt;&lt;1 和 rt&lt;&lt;1|1 来表示左右子节点, 而需要在 node 中记录 lson 和 rson 的编号, 如下.</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r, val, lazy;</span><br><span class="line">&#125;st[maxn];</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>update 时如果需要开点则开点. </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> &amp;rt, <span class="type">int</span> l, <span class="type">int</span> r, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!rt) rt = ++cnt;</span><br><span class="line">    <span class="keyword">if</span>(l == r)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span>() <span class="built_in">update</span>(...);</span><br><span class="line">    <span class="keyword">if</span>() <span class="built_in">update</span>(...);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">pushup</span>(rt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>查询时同理.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> rt, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> L, <span class="type">int</span> R...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!rt) <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">if</span>(l &lt;= L &amp;&amp; R &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="权值线段树"><a href="#权值线段树" class="headerlink" title="权值线段树"></a>权值线段树</h1><p>什么是权值线段树?</p>
<blockquote>
<p>以权值为维护信息的线段树，本质仍是线段树。、</p>
</blockquote>
<p>不同于普通线段树维护的区间信息, 权值线段树维护的是固定值域内的元素的个数.<br><del>这不就是桶嘛</del></p>
<p>举个栗子<br>有个数列 $ 1, 1, 2, 2, 2, 3, 3, 4, 5 $<br>节点 $ [1, 1] $ 的值为 2 代表数列中位于 $ [1, 1] $ 的数有 2 个.<br>同理节点 $ [1, 2] $ 的值为 5 , $ [1, 5] $ 的值为 9 .</p>
<h1 id="主席树（可持久化线段树）"><a href="#主席树（可持久化线段树）" class="headerlink" title="主席树（可持久化线段树）"></a>主席树（可持久化线段树）</h1><blockquote>
<p>主席树是一种<del>霸气的</del>，持久的，基于线段树的数据结构。</p>
</blockquote>
<p>可持久化线段树, 顾名思义, 就是支持回退操作的线段树(<del>完全理解不了好不好</del>)</p>
<p>主席树由权值线段树引申而来, 可以维护区间第k小.<br>思想是开一个 root[] 数组存储 i 版本的根节点.<br>每次更新时对于需要更新的节点直接新建, 对于不需要更新的节点直接连到更新的节点上.</p>
<p>附上主席树求区间第k小代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mid ((l+r)&gt;&gt;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i, a, b) for(int i=(a); i&lt;=(b); i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 1000020</span></span><br><span class="line"><span class="type">int</span> a[maxn], b[maxn], t[maxn], n, m, k;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">str</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> l, r, val;</span><br><span class="line">&#125;tree[maxn&lt;&lt;<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> top;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">char</span> ch=<span class="built_in">getchar</span>(); <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>) ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) ans=(ans&lt;&lt;<span class="number">3</span>)+(ans&lt;&lt;<span class="number">1</span>)+(ch^<span class="number">48</span>), ch=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">build</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> node=++top;</span><br><span class="line">	<span class="keyword">if</span>(l!=r)</span><br><span class="line">	&#123;</span><br><span class="line">		tree[node].l=<span class="built_in">build</span>(l, mid);</span><br><span class="line">		tree[node].r=<span class="built_in">build</span>(mid+<span class="number">1</span>, r);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">clone</span><span class="params">(<span class="type">int</span> node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	tree[++top]=tree[node];</span><br><span class="line">	tree[top].val++;</span><br><span class="line">	<span class="keyword">return</span> top;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">update</span><span class="params">(<span class="type">int</span> pre, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> node=<span class="built_in">clone</span>(pre);</span><br><span class="line">	<span class="keyword">if</span>(l!=r)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(x&lt;=mid)	tree[node].l=<span class="built_in">update</span>(tree[node].l, l, mid, x);</span><br><span class="line">		<span class="keyword">else</span>		tree[node].r=<span class="built_in">update</span>(tree[node].r, mid+<span class="number">1</span>, r, x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l==r)	<span class="keyword">return</span> b[l];</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> node=tree[tree[v].l].val-tree[tree[u].l].val;</span><br><span class="line">		<span class="keyword">if</span>(k&lt;=node)	<span class="keyword">return</span> <span class="built_in">query</span>(tree[u].l, tree[v].l, l, mid, k);</span><br><span class="line">		<span class="keyword">else</span>		<span class="keyword">return</span> <span class="built_in">query</span>(tree[u].r, tree[v].r, mid+<span class="number">1</span>, r, k-node);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">	<span class="built_in">rep</span>(i, <span class="number">1</span>, n) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]), b[i]=a[i];</span><br><span class="line">	<span class="built_in">sort</span>(b+<span class="number">1</span>, b+n+<span class="number">1</span>);</span><br><span class="line">	<span class="type">int</span> size=<span class="built_in">unique</span>(b+<span class="number">1</span>, b+n+<span class="number">1</span>)-(b+<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">rep</span>(i, <span class="number">1</span>, n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> x=<span class="built_in">lower_bound</span>(b+<span class="number">1</span>, b+size+<span class="number">1</span>, a[i])-b;</span><br><span class="line">		t[i]=<span class="built_in">update</span>(t[i<span class="number">-1</span>], <span class="number">1</span>, size, x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">rep</span>(i, <span class="number">1</span>, m)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> l=<span class="built_in">read</span>(), r=<span class="built_in">read</span>(), k=<span class="built_in">read</span>();</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">query</span>(t[l<span class="number">-1</span>], t[r], <span class="number">1</span>, size, k));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="线段树合并"><a href="#线段树合并" class="headerlink" title="线段树合并"></a>线段树合并</h1><p>待更</p>
<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p>待更</p>
]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>动态开点线段树</tag>
        <tag>权值线段树</tag>
        <tag>线段树合并</tag>
        <tag>可持久化线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>最长公共上升子序列(LCIS)</title>
    <url>/2024/07/25/%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h2 id="什么是最长公共上升子序列-bushi"><a href="#什么是最长公共上升子序列-bushi" class="headerlink" title="什么是最长公共上升子序列(bushi)"></a>什么是最长公共上升子序列(bushi)</h2><blockquote>
<p>最长公共上升子序列就是最长的公共的上升的子序列(子序列不需要连续哦)</p>
</blockquote>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><h4 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h4><p>显然考虑dp, $ dp_{i,j} $ 表示选取序列 a 的前 i 个元素, lcis以 $ b_i $ 结尾的最长公共子序列的长度</p>
<h4 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h4><ol>
<li>$ a_i \neq b_i $ : $ dp_{i, j} \gets dp_{i - 1, j} $<br>//如果 $ a_i \neq b_i $ , 那么在以 $ b_i $ 结尾的公共子序列中一定不选 $ a_i $</li>
<li>$ a_i = b_i $ : $ dp_{i, j} \gets max(dp_{i - 1, k}), k &lt; j $<br>////如果 $ b_k $小于 $ b_j $, 那么便可由 $ b_k $ 转移, 注意 $ a_i $ 已经和 $ b_i $ 配对所以不考虑</li>
</ol>
<p>附上代码:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 100020</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i, a, b) for(int i = (a); i &lt;= (b); i ++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> love return</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> you 0</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dp[<span class="number">5001</span>][<span class="number">5001</span>];</span><br><span class="line"><span class="type">int</span> a[maxn], b[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;a.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;a.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n, m; cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) cin &gt;&gt; a[i];</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    <span class="built_in">rep</span>(j, <span class="number">1</span>, m) cin &gt;&gt; b[j];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// rep(i, 1, n) cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;;</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// rep(i, 1, m) cout &lt;&lt; b[i] &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">rep</span>(j, <span class="number">1</span>, m)</span><br><span class="line">        &#123; </span><br><span class="line">            dp[i][j] = dp[i - <span class="number">1</span>][j]; <span class="comment">//如果a_i != b_i, 那么在以b_i结尾的公共子序列中一定不选a_i</span></span><br><span class="line">            <span class="keyword">if</span>(a[i] == b[j])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> mx = <span class="number">0</span>;</span><br><span class="line">                <span class="built_in">rep</span>(k, <span class="number">1</span>, j - <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(b[k] &lt; b[j])</span><br><span class="line">                    &#123;</span><br><span class="line">                        mx = <span class="built_in">max</span>(mx, dp[i - <span class="number">1</span>][k]); <span class="comment">//如果b[k]小于b[i], 那么便可由b[k]转移, 注意a_i已经和b_i配对所以不考虑</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                mx += <span class="number">1</span>;</span><br><span class="line">                dp[i][j] = mx;</span><br><span class="line">            &#125;    </span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, m) ans = <span class="built_in">max</span>(ans, dp[n][i]);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    love you;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>但考虑到最坏情况下复杂度会退化到 $ O(n^3) $,  所以有没有什么方案可以再进一步降低复杂度呢?</p>
<p>我们可以发现 $ a_i = b_j, b_j &gt; b_k $ 和 $ a_i &gt; b_j $ 是等价的.</p>
<p>所以在第二层循环中只需要记一个 mxdp 来维护当前 $ dp_{i, j} 的最大值就好</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 100020</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i, a, b) for(int i = (a); i &lt;= (b); i ++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> love return</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> you 0</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dp[<span class="number">5001</span>][<span class="number">5001</span>];</span><br><span class="line"><span class="type">int</span> a[maxn], b[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;a.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;a.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n, m; cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n) cin &gt;&gt; a[i];</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    <span class="built_in">rep</span>(j, <span class="number">1</span>, m) cin &gt;&gt; b[j]; </span><br><span class="line"></span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mx = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">rep</span>(j, <span class="number">1</span>, m)</span><br><span class="line">        &#123; </span><br><span class="line">            dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">if</span>(a[i] &gt; b[j]) mx = <span class="built_in">max</span>(mx, dp[i][j]);</span><br><span class="line">            <span class="keyword">if</span>(a[i] == b[j]) dp[i][j] = mx + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">rep</span>(i, <span class="number">1</span>, m) ans = <span class="built_in">max</span>(ans, dp[n][i]);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    love you;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><del>显然还可以使用滚动数组优化空间, 但滚动数组我不想写</del></p>
<h1 id="寄"><a href="#寄" class="headerlink" title="寄"></a>寄</h1>]]></content>
      <tags>
        <tag>动态规划</tag>
        <tag>最长公共子序列</tag>
        <tag>最长公共上升子序列</tag>
      </tags>
  </entry>
  <entry>
    <title>扫描线</title>
    <url>/2024/07/24/%E6%89%AB%E6%8F%8F%E7%BA%BF/</url>
    <content><![CDATA[<p>from OI-WIKI</p>
<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>在二维坐标系上，给出多个矩形的左下以及右上坐标，求出所有矩形构成的图形的面积。</p>
<h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><p>现在假设我们有一根线，从下往上开始扫描：<br><del>(图片)</del></p>
<ol>
<li>如图所示，我们可以把整个矩形分成如图各个颜色不同的小矩形，那么这个小矩形的高就是我们扫过的距离，那么剩下了一个变量，那就是矩形的长一直在变化。</li>
<li>我们的线段树就是为了维护矩形的长，我们给每一个矩形的上下边进行标记，下面的边标记为 $1$，上面的边标记为 $-1$，每遇到一个矩形时，我们知道了标记为 $1$ 的边，我们就加进来这一条矩形的长，等到扫描到 $-1$ 时，证明这一条边需要删除，就删去，利用 $1$ 和 $-1$ 可以轻松的到这种状态。</li>
<li>还要注意这里的线段树指的并不是线段的一个端点，而指的是一个区间，所以我们要计算的是 $r+1$ 和 $r-1$。</li>
<li>需要 离散化。</li>
</ol>
<p>附上代码及注释：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 1000020</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i, a, b) for(int i = (a); i &lt;= (b); i ++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lson (rt&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rson (rt&lt;&lt;1|1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mid ((l+r)&gt;&gt;1)</span></span><br><span class="line"><span class="comment">//记得加括号（（</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> love return</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> you 0</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> segment_tree</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l, r, len, sum;</span><br><span class="line">        <span class="comment">//记录节点的左端点，右端点，此点对应的长度，以及我们需要增加总长度还是减小总长度（是矩形的靠前边否）</span></span><br><span class="line">    &#125;st[maxn&lt;&lt;<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">segment</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l, r, h, vul; </span><br><span class="line">        <span class="comment">//记录此线段的左端点右端点，高度和靠前边否</span></span><br><span class="line">    &#125;segg[maxn&lt;&lt;<span class="number">2</span>];</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(segment a, segment b)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        love a.h &lt; b.h;</span><br><span class="line">        <span class="comment">//我们需要将边按照高度排序</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> X[maxn];</span><br><span class="line">    <span class="comment">//记录线段树中需要存储的点（不相同的点）</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> rt)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(st[rt].sum)</span><br><span class="line">        &#123;</span><br><span class="line">            st[rt].len = X[st[rt].r + <span class="number">1</span>] - X[st[rt].l];</span><br><span class="line">            <span class="comment">//当被完全覆盖的节点需要改变时改变</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            st[rt].len = st[lson].len + st[rson].len;</span><br><span class="line">            <span class="comment">//不是被完全覆盖的节点或者此节点没有贡献</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        love ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> rt, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        st[rt].l = l; st[rt].r = r;</span><br><span class="line">        st[rt].len = <span class="number">0</span>; st[rt].sum = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">if</span>(l == r) </span><br><span class="line">        &#123;</span><br><span class="line">            love ;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="built_in">build</span>(lson, l, mid);</span><br><span class="line">        <span class="built_in">build</span>(rson, mid + <span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">        love ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> rt, <span class="type">int</span> al_l, <span class="type">int</span> al_r, <span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = st[rt].l, r = st[rt].r;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(X[l] &gt;= al_r || X[r + <span class="number">1</span>] &lt;= al_l) love ;</span><br><span class="line">        <span class="comment">//剪枝</span></span><br><span class="line">        <span class="keyword">if</span>(X[l] &gt;= al_l &amp;&amp; X[r + <span class="number">1</span>] &lt;= al_r)</span><br><span class="line">        &#123;</span><br><span class="line">            st[rt].sum += val;</span><br><span class="line">            <span class="comment">//如果此节点被完全覆盖</span></span><br><span class="line">            <span class="built_in">pushup</span>(rt);</span><br><span class="line">            <span class="comment">//在此时就回传</span></span><br><span class="line">            love ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">update</span>(lson, al_l, al_r, val);</span><br><span class="line">        <span class="built_in">update</span>(rson, al_l, al_r, val);</span><br><span class="line">        <span class="built_in">pushup</span>(rt);</span><br><span class="line">        <span class="comment">//回传</span></span><br><span class="line">        love ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">1</span>, n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x1, y1, x2, y2; cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2;</span><br><span class="line">            <span class="comment">//输入</span></span><br><span class="line">            segg[(i &lt;&lt; <span class="number">1</span>) - <span class="number">1</span>] = (segment)&#123;x1, x2, y1, <span class="number">1</span>&#125;;</span><br><span class="line">            segg[(i &lt;&lt; <span class="number">1</span>)]     = (segment)&#123;x1, x2, y2, <span class="number">-1</span>&#125;;</span><br><span class="line">            <span class="comment">//我们需要存n*2条边，这里的处理只是为了存储恰好为n*2，没有有顺序的意思</span></span><br><span class="line">            X[(i &lt;&lt; <span class="number">1</span>) - <span class="number">1</span>] = x1;</span><br><span class="line">            X[(i &lt;&lt; <span class="number">1</span>)] = x2;</span><br><span class="line">            <span class="comment">//存点</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        n &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">sort</span>(segg + <span class="number">1</span>, segg + <span class="number">1</span> + n, cmp);</span><br><span class="line">        <span class="built_in">sort</span>(X + <span class="number">1</span>, X + n + <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> cnt = <span class="built_in">unique</span>(X + <span class="number">1</span>, X + n + <span class="number">1</span>) - X - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//去重函数，重点记忆！</span></span><br><span class="line">        <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, cnt - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//建树</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// rep(i, 1, n) cout &lt;&lt; segg[i].h &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">// rep(i, 1, n) cout &lt;&lt; X[i] &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">rep</span>(i, <span class="number">1</span>, n - <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">update</span>(<span class="number">1</span>, segg[i].l, segg[i].r, segg[i].vul); </span><br><span class="line">            ans += st[<span class="number">1</span>].len * (segg[i + <span class="number">1</span>].h - segg[i].h);</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">        love you;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;a.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;a.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    segment_tree::<span class="built_in">main</span>();</span><br><span class="line"></span><br><span class="line">    love you;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>一道例题 <a href="https://luogu.com.cn/problem/P1502">P1502</a></p>
<p>附上<del>我也不知道怎么对</del>的代码。。。<br><del>回头再调</del></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">// #define int long long</span><br><span class="line">#define rep(i, a, b) for(int i = (a); i &lt;= (b); i ++)</span><br><span class="line">#define lson (rt&lt;&lt;1)</span><br><span class="line">#define rson (rt&lt;&lt;1|1)</span><br><span class="line">// #define mi ((l+r)&gt;&gt;1)</span><br><span class="line">#define maxn 300010</span><br><span class="line">#define int long long</span><br><span class="line">#define love return</span><br><span class="line">#define you 0</span><br><span class="line">int T, n, w, h, C[maxn];</span><br><span class="line">// 组数，元素个数，宽，高</span><br><span class="line"></span><br><span class="line">// namespace line_sweep</span><br><span class="line">// &#123;</span><br><span class="line">    // int C[maxn&lt;&lt;2];</span><br><span class="line">    //存横坐标</span><br><span class="line">    struct segment&#123;</span><br><span class="line">        int l,r,h;</span><br><span class="line">        int val;</span><br><span class="line">        bool operator &lt;(const segment &amp;a)const&#123;</span><br><span class="line">            return (h!=a.h)?h&lt;a.h:val&gt;a.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;segg[maxn&lt;&lt;2];</span><br><span class="line">    struct node&#123;</span><br><span class="line">        int l,r;</span><br><span class="line">        int mx,add;</span><br><span class="line">    &#125;st[maxn&lt;&lt;2];</span><br><span class="line"></span><br><span class="line">    void pushup(int rt)</span><br><span class="line">    &#123;</span><br><span class="line">        st[rt].mx = max(st[lson].mx, st[rson].mx);    </span><br><span class="line">        //上推</span><br><span class="line">        love ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void pushdown(int rt)</span><br><span class="line">    &#123;</span><br><span class="line">        st[lson].mx += st[rt].add;</span><br><span class="line">        st[rson].mx += st[rt].add;</span><br><span class="line">        st[lson].add += st[rt].add;</span><br><span class="line">        st[rson].add += st[rt].add;</span><br><span class="line"></span><br><span class="line">        st[rt].add = 0;</span><br><span class="line">        //下推</span><br><span class="line">        love ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void build(int rt, int l, int r)//建树</span><br><span class="line">    &#123;</span><br><span class="line">        st[rt].l = l, st[rt].r = r;</span><br><span class="line">        st[rt].add = 0; st[rt].mx = 0;</span><br><span class="line">        if(l == r) love ;</span><br><span class="line">        int mi = (l+r)&gt;&gt;1;</span><br><span class="line">        build(lson, l, mi);</span><br><span class="line">        build(rson, mi + 1, r);</span><br><span class="line">    &#125;</span><br><span class="line">    // void build(int x,int l,int r)&#123;</span><br><span class="line">    //     st[x].l=l,st[x].r=r,st[x].mx=st[x].add=0;</span><br><span class="line">    //     if(l==r)return;</span><br><span class="line">    //     int mi=(l+r)&gt;&gt;1;</span><br><span class="line">    //     build(x&lt;&lt;1,l,mi);</span><br><span class="line">    //     build(x&lt;&lt;1|1,mi+1,r);</span><br><span class="line">    // &#125;</span><br><span class="line"></span><br><span class="line">    void update(int rt, int al_l, int al_r, int val)//上传</span><br><span class="line">    &#123;</span><br><span class="line">        int l = st[rt].l, r = st[rt].r;</span><br><span class="line">        if(l &gt;= al_l &amp;&amp; r &lt;= al_r)</span><br><span class="line">        &#123;</span><br><span class="line">            st[rt].mx += val;</span><br><span class="line">            st[rt].add += val;</span><br><span class="line">            love ;</span><br><span class="line">        &#125;</span><br><span class="line">        pushdown(rt);</span><br><span class="line">        </span><br><span class="line">	    int mi=(l+r)&gt;&gt;1;</span><br><span class="line">        if(al_l &lt;= mi)update(lson, al_l, al_r, val);</span><br><span class="line">        if(al_r &gt; mi)update(rson, al_l, al_r, val);</span><br><span class="line">        pushup(rt);</span><br><span class="line">    &#125;</span><br><span class="line">    void init()//初始化</span><br><span class="line">    &#123;</span><br><span class="line">        memset(segg, 0, sizeof(segg));</span><br><span class="line">        memset(st, 0, sizeof(st));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // signed main()</span><br><span class="line">    // &#123;</span><br><span class="line">    //     init();</span><br><span class="line">    //     rep(i, 1, n)</span><br><span class="line">    //     &#123;</span><br><span class="line">    //         int x, y, v; cin &gt;&gt; x &gt;&gt; y &gt;&gt; v;</span><br><span class="line">    //         C[(i &lt;&lt; 1) - 1] = y; </span><br><span class="line">    //         C[(i &lt;&lt; 1)] = y + h - 1;</span><br><span class="line">    //         segg[(i &lt;&lt; 1) - 1] = (segment)&#123;y, y + h - 1, x, v&#125;;</span><br><span class="line">    //         segg[(i &lt;&lt; 1)] = (segment)&#123;y, y + h - 1, x + w - 1, -v&#125;;</span><br><span class="line">    //     &#125;</span><br><span class="line"></span><br><span class="line">    //     n &lt;&lt;= 1;</span><br><span class="line"></span><br><span class="line">    //     sort(segg + 1, segg + n + 1);</span><br><span class="line">    //     sort(X + 1, X + n + 1);</span><br><span class="line">    //     int cnt = unique(X + 1, X + n + 1) - (X + 1);</span><br><span class="line"></span><br><span class="line">    //     rep(i, 1, n)</span><br><span class="line">    //     &#123;</span><br><span class="line">    //         int pos1 = lower_bound(X + 1, X + cnt + 1, segg[i].l) - X;</span><br><span class="line">    //         int pos2 = lower_bound(X + 1, X + cnt + 1, segg[i].r) - X;</span><br><span class="line">    //         segg[i].r = pos2; </span><br><span class="line">    //         segg[i].l = pos1;</span><br><span class="line">    //     &#125;</span><br><span class="line"></span><br><span class="line">    //     build(1, 1, cnt);</span><br><span class="line"></span><br><span class="line">    //     int ans = 0;</span><br><span class="line"></span><br><span class="line">    //     rep(i, 1, n)</span><br><span class="line">    //     &#123;</span><br><span class="line">    //         update(1, segg[i].l, segg[i].r, segg[i].val);</span><br><span class="line">    //         ans = max(ans, st[1].mx);</span><br><span class="line">    //     &#125;</span><br><span class="line"></span><br><span class="line">    //     cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        // love you;</span><br><span class="line">    // &#125;</span><br><span class="line">// &#125;</span><br><span class="line"></span><br><span class="line">signed main()</span><br><span class="line">&#123;</span><br><span class="line">    // freopen(&quot;a.in&quot;, &quot;r&quot;, stdin);</span><br><span class="line">    // freopen(&quot;a.out&quot;, &quot;w&quot;, stdout);</span><br><span class="line">    // cin &gt;&gt; T;</span><br><span class="line">    // while(T --)</span><br><span class="line">    // &#123;</span><br><span class="line">// 3 5 4</span><br><span class="line">// 1 2 3</span><br><span class="line">// 2 3 2</span><br><span class="line">// 6 3 1</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; w &gt;&gt; h;</span><br><span class="line">        // init();</span><br><span class="line">        rep(i, 1, n)</span><br><span class="line">        &#123;</span><br><span class="line">            int x, y, v; cin &gt;&gt; x &gt;&gt; y &gt;&gt; v;</span><br><span class="line">            C[(i &lt;&lt; 1) - 1] = y; </span><br><span class="line">            C[(i &lt;&lt; 1)] = y + h - 1;</span><br><span class="line">            segg[(i &lt;&lt; 1) - 1] = (segment)&#123;y, y + h - 1, x, v&#125;;</span><br><span class="line">            segg[(i &lt;&lt; 1)] = (segment)&#123;y, y + h - 1, x + w - 1, -v&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        n &lt;&lt;= 1;</span><br><span class="line"></span><br><span class="line">        sort(segg + 1, segg + n + 1);</span><br><span class="line">        sort(C + 1, C + n + 1);</span><br><span class="line">        int cnt = unique(C + 1, C + n + 1) - (C + 1);</span><br><span class="line"></span><br><span class="line">        rep(i, 1, n)</span><br><span class="line">        &#123;</span><br><span class="line">            int pos1 = lower_bound(C + 1, C + cnt + 1, segg[i].l) - C;</span><br><span class="line">            int pos2 = lower_bound(C + 1, C + cnt + 1, segg[i].r) - C;</span><br><span class="line">            segg[i].r = pos2; </span><br><span class="line">            segg[i].l = pos1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        build(1, 1, cnt);</span><br><span class="line"></span><br><span class="line">        int ans = 0;</span><br><span class="line"></span><br><span class="line">        rep(i, 1, n)</span><br><span class="line">        &#123;</span><br><span class="line">            update(1, segg[i].l, segg[i].r, segg[i].val);</span><br><span class="line">            ans = max(ans, st[1].mx);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">        // line_sweep::main();</span><br><span class="line">    // &#125;</span><br><span class="line"></span><br><span class="line">    love you;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>扫描线</tag>
      </tags>
  </entry>
  <entry>
    <title>失眠的信</title>
    <url>/2024/07/25/%E6%9D%82%E5%BF%B5/</url>
    <content><![CDATA[<p>这会是一个不眠的夜吗？</p>
<p>望着无光晦暗的天花板，有人彷徨迷茫，有人无助忧伤。</p>
<p>那就请转头看看窗外吧，看看繁星为谁而闪烁，看看明月为谁而高悬。</p>
<p>去看看不灭的城市中车流穿梭，编织着无数失眠的梦想；去看看楼房的窗户里灯光常亮，浸染着数不清的纸短情长。</p>
<p>不要忘记了，在这个世界上还有许多人将会与你遇见，还有许多人正等待着被你遇见。</p>
<p>城市万家灯火，总有一盏为你而开；世间繁华万千，总有一种为你而来。</p>
<p>失眠的人啊，</p>
<p>请安心睡去。</p>
<p>因为，</p>
<p>明天就在那里。</p>
]]></content>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
</search>
